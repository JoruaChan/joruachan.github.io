{"meta":{"title":"JoruaChan技术博客","subtitle":"永远不甘于现状","description":"","author":"JoruaChan","url":"http://joruachan.cn","root":"/"},"pages":[{"title":"","date":"2021-09-09T16:25:46.916Z","updated":"2021-09-09T16:25:46.916Z","comments":false,"path":"404.html","permalink":"http://joruachan.cn/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-09-08T15:26:46.608Z","updated":"2021-09-08T15:26:46.608Z","comments":true,"path":"chat/index.html","permalink":"http://joruachan.cn/chat/index.html","excerpt":"","text":""},{"title":"更新日记 and 计划","date":"2021-09-13T15:57:55.927Z","updated":"2021-09-13T15:57:55.927Z","comments":false,"path":"changelog/index.html","permalink":"http://joruachan.cn/changelog/index.html","excerpt":"","text":"2021-09-17 (plan) debug代码——Spring代理 2021-09-13 界面优化 完善 《史上最全synchronized关键字总结》 2021-09-08 界面优化增加”闲谈”区域","author":"Jorua"},{"title":"","date":"2021-09-09T15:19:44.131Z","updated":"2021-09-09T15:19:44.131Z","comments":true,"path":"about/index.html","permalink":"http://joruachan.cn/about/index.html","excerpt":"","text":"「 In me the tiger sniffs the rose;(心有猛虎，细嗅蔷薇) 」 —— Siegfried Sassoon（译自余光中） 如果此时你翻到此页，我是否可以自信地问你一声：是我的博客某方面吸引到你了吧！哈哈，笔者开了个玩笑，一直想要搭建个属于自己的博客，苦于各种原因，或者说自己没有静下心来落实这件事。 在这个“阳光明媚”的夜晚，我坚定地告诉你们，我肯定会努力建设本博客站的！不仅博客，包括我的GitHub项目，我会争取每天、每周更新、发布的！ 博客介绍我简单介绍下，本博客网站的主要建设思路，内容展示区域主要分成首页、随笔、闲谈和归档。 首页，是想分享个人觉得不错的文章或者趣事； 随笔，可以看成技术相关的笔记本，文章内容偏于生产事件、学习发现而引出的技术讨论点； 闲谈，每个人都会有自己的生活，我也想将我的事情或者心里话分享给老铁们； 归档，将我编写或转载的所有文章集中归档于此，方便查阅； 可能你看过我的某篇文章，想重新翻阅，但是你没有收藏。不要慌，导航栏看到没有？”Search Something…”看到没有？对，敲入你的关键字，让我帮你想！ 更新日记来吧，翻开日记本！ 记录博客建设 2021-09-07 重启博客计划 稳定了，心也跟着安定了。经历了太多，重拾博客！ 2021-01-26 域名备案完成 joruachan.cn 终于有了专属于我自己的域名啦，撒花！✿✿ヽ(°▽°)ノ✿ 2021-01-17 初步搭建 是时候觉得应该搭建一个博客了，之前了解过hexo，但是一直没有着手实践；选择了Volantis主题，实践完后，体验非常好。操作简单、搭建方便，并且博客整体样式显得很年轻化，适合我们年老心未老的老年人！哈哈，坚持写作、记录技术！期待我的博客能够越来越火！希望你们能挺我起来！ 最后我相信每个博主建设博客网站，除了分享知识和生活，肯定还想多交朋友。如果我的博客能得到你的芳心， 点赞收藏不要紧张哦！ 另外，如果您有任何建议或者疑问，欢迎在此页进行留言！"},{"title":"","date":"2021-08-25T10:52:55.652Z","updated":"2021-08-25T10:52:55.652Z","comments":true,"path":"essay/index.html","permalink":"http://joruachan.cn/essay/index.html","excerpt":"","text":""}],"posts":[{"title":"disruptor初次见面","slug":"the-first-time-2-meet-disruptor","date":"2021-09-14T16:00:00.000Z","updated":"2021-09-15T15:22:33.038Z","comments":true,"path":"2021-09-15/the-first-time-2-meet-disruptor/","link":"","permalink":"http://joruachan.cn/2021-09-15/the-first-time-2-meet-disruptor/","excerpt":"","text":"每每复习Java数据结构时候，总感觉在队列中找不到一个适合高并发场景的队列。JDK提供的队列模型不尽人意，那么今天将要像大家简单介绍下： Disruptor，一个适用于多线程间高并发交换数据的有界队列； 简单说几点，就能体现Disruptor的神奇： 在并发情况下，普通的内存队列处理速度，和IO速度处于同一个数量级； 基于Disruptor开发的系统单线程能支撑每秒600万订单； 生产者消费者的环形队列，无锁； 怎么样，是不是魅力很大？确实，目前GitHub上已经有14k+的Star了。 大家可以先阅读下其GitHub站，以及文档。我会将Disruptor的详细说明列入博客计划。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://joruachan.cn/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://joruachan.cn/tags/%E6%A1%86%E6%9E%B6/"},{"name":"高并发","slug":"高并发","permalink":"http://joruachan.cn/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"数据结构","slug":"数据结构","permalink":"http://joruachan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"Jorua"},{"title":"这是我的一半2021","slug":"half-of-2021","date":"2021-09-07T15:34:22.000Z","updated":"2021-09-08T15:25:26.088Z","comments":true,"path":"2021-09-07/half-of-2021/","link":"","permalink":"http://joruachan.cn/2021-09-07/half-of-2021/","excerpt":"","text":"这篇文章起笔时间，2021年9月7日晚上。 间隔上篇博文，又过去了5个多月。中间发生了很多事，似乎明白了很多，让我坚定了很多选择；但是似乎又增添了不少疑惑，疑惑那些打破我认知的事情。不要觉得我矫情，也许你们觉得很正常，于我来说，可能正在经历生活、职场等等方面的历练。 简单说下吧。 婚姻，我们在三年恋爱后，终于————我迎娶她成为了丈夫，她嫁给我成为了妻子；感谢有她，庆幸有她！ 新房，房子在婚姻上我认为是个必需品，媳妇和我花了不少时间、心思在装配上，完美收官让我们心满意足；愿家愈来愈好！ 离职，陪上家公司经历了一段最困难的时期，不舍归不舍，生活还是要继续；祝福它吧！ 新城市，朝钱看所以我换了城市，上午仍在家，下午奔至另一个城市，快节奏让我觉得哪哪都是陌生的；但愿新城市温柔点！ 新工作，在我第四年的工作经验情况下，让我时时自己问自己：原来你不知道的还是有这么多？当然更多的原因是没有接触过的业务；卷起来吧！ 2021不一般！带着憧憬，带着责任，全力以赴。当然现在，所有的一切都逐渐稳定了。所以，我，Jorua又回来啦！","categories":[{"name":"随便聊聊","slug":"随便聊聊","permalink":"http://joruachan.cn/categories/%E9%9A%8F%E4%BE%BF%E8%81%8A%E8%81%8A/"}],"tags":[{"name":"除了工作以外的","slug":"除了工作以外的","permalink":"http://joruachan.cn/tags/%E9%99%A4%E4%BA%86%E5%B7%A5%E4%BD%9C%E4%BB%A5%E5%A4%96%E7%9A%84/"}],"author":"Jorua"},{"title":"史上最全synchronized关键字总结","slug":"synchronized-summary","date":"2021-03-21T16:00:00.000Z","updated":"2021-09-13T15:49:20.317Z","comments":true,"path":"2021-03-22/synchronized-summary/","link":"","permalink":"http://joruachan.cn/2021-03-22/synchronized-summary/","excerpt":"","text":"文章思路我在阅读文章时，更希望文章有个提纲或者思路，在阅读前可以理解他的思路，这样能快速明白他想说什么，将要怎么说。 本篇文章编写的思路： 回顾下理论知识：信号量。因为信号量是解决并发过程中互斥和同步问题的最基础的模型; 介绍管程模型，管程模型是针对信号量的一个改进模型; 再介绍Java中是如何实现和使用管程模型的; 最后介绍下Java对synchronized重量级锁的优化; 信号量你的脑袋里，是不是还能蹦出共享资源、临界区、P方法、V方法等等字眼词汇？那说明你的课本知识还是很扎实的！ 信号量机制是由荷兰学者Dijkstra提出的进程同步工具，它被大量使用在处理机系统和计算机网络中！其中，包含了两个重要属性和两个重要的方法。 PS：我这里介绍的内容，为了更好的理解经过了一定的加工，不完全和理论介绍一致！ 两个重要属性 count，共享资源数量，count &gt; 0表示还存在共享资源可以获取，count &lt; 0则表示共享资源已经获取完了，只能等资源被释放； 等待队列，当count &lt; 0时，线程需阻塞直到资源释放，这些线程需要加入到等待队列中； 两个重要方法 P：获取资源，即对count-1，如果结果&gt;=0，则获取资源成功；但是结果&lt;0的话，线程则加入到等待队列并进入阻塞状态； V：释放资源，即对count+1，如果结果&gt;0，则不做特殊操作；但是结果&lt;=0，则表示有线程需要共享资源，则从等待队列中唤醒一个线程恢复执行； 使用方法 只有P和V方法能操作count属性； P和V方法必须成对出现，否则对共享资源的控制不准确； P方法可能阻塞，但是不能无限期阻塞； 问题 易造成死锁 如果一段逻辑中存在多个信号量间的交互，有着很经典的问题：比如A和B间，A依赖着B，B又依赖着A，如果控制不合理，很容易造成死锁； 饥饿现象 调度器的不公平，会造成线程等待时间较长产生饥饿现象； 对程序员不友好 如果依靠信号量间来完成多个临界区的同步或者互斥，那么会有大量的P/V方法，难以维护； 管程管程模型是在信号量的基础上改进的模型，很大程度上解决了上述信号量存在的问题，并且隐藏了很多同步细节。 改进点· 吞吐量提高 管程模型允许多个进（线）程先进入模型，再根据同步条件来判断是否能进入临界区；而信号量模型同一个信号量不论何种情况，都只能一个进（线）程进入； · 条件队列（条件同步） 管程模型在信号量模型的基础上，添加了条件同步概念。通过使用条件队列，已经获得共享资源的进（线）程可以释放共享资源，并将进（线）程添加到条件队列中阻塞，一直等到某个条件成立，使得该进（线）程回到等待队列重新获取共享资源，再继续执行后续逻辑；具体的代码实现可以参考j.u.c中的Condition接口和具体实现； 管程和信号量的比较，图片来自于网络 深入理解在信号量的模型中，一个共享变量需要一个信号量模型支持；如果存在多个共享变量，就需要多个信号量来支持。 举例说明：两个共享资源A和B以及对应的信号量Sa和Sb；一个线程Ta利用Sa信号量的P方法获取到共享资源A，然后尝试获取共享资源B（未执行V方法）；另一个线程Tb在Ta获取到A的同时也获取到B，然后Tb又需要获取A。则最后的现象就是Ta需要等待Tb释放B，Tb在等Ta释放A，谁也不放过谁，而造成了死锁；具体可以参照伪代码理解： 信号量死锁伪代码1234567891011121314151617181920212223Sa&#123; int A; P()&#123; // 阻塞直到满足条件 if(--A &gt;= 0) &#123; ... Sb.P() ... &#125; &#125;&#125;Sb&#123; int B; P()&#123; // 阻塞直到满足条件 if(--B &gt;= 0) &#123; ... Sa.P() ... &#125; &#125;&#125; 管程则针对上述问题，提出一个更方便、更易理解的模型。从线程的角度去管理和协调共享资源，拥有管程的线程可以放弃使用权，并等待恢复。 从而解决上述列出的伪代码的问题了！ 管程伪代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Sa&#123; int A; P()&#123; while(true)&#123; if(获取共享资源A成功)&#123; ... while(true)&#123; if (获取共享资源B成功) &#123; ... // 唤起等待资源B的线程 Sb.notify() break; &#125; else &#123; // 释放共享资源A的控制权 Sa.wait() &#125; &#125; ... Sa.notify() break; &#125; &#125; &#125; wait()&#123; // 释放A的控制权 &#125; notify()&#123; // 唤起等待A的线程 &#125;&#125;Sb&#123; int B; P()&#123; while(true)&#123; if(获取共享资源B成功)&#123; ... while(true)&#123; if (获取共享资源A成功) &#123; ... // 唤起等待资源A的线程 Sa.notify() break; &#125; else &#123; // 释放共享资源B的控制权 Sb.wait() &#125; &#125; ... Sb.notify() break; &#125; &#125; &#125; wait()&#123; // 释放B的控制权 &#125; notify()&#123; // 唤起等待B的线程 &#125;&#125; 如上，通过wait和notify两个方法，可以很好地解决多个共享变量间的协调问题； MESA模型管程的具体实现，当前最流行的就是MESA模型。它有个基本的编程范式：在一个while循环里面调用wait()，增加一个超时参数防止饥饿； 除了MESA模型，还有Hoare模型和Brinch Hanson 模型，感兴趣的同学可以了解下。 synchronized底层原理字节码表现我们先来举个例子： SynchronizedTest.java123456789101112131415161718192021public class SynchronizedTest &#123; int count = 0; // 普通方法 public void normalMethod() &#123; count++; &#125; // 同步方法，只能锁住当前实例的对象 public synchronized void syncMethod() &#123; count++; &#125; // 同步代码块，这里可以指定同步资源 public void syncCodeBlock() &#123; synchronized(this) &#123; count++; &#125; &#125;&#125; 这段代码很简单，一个普通的方法，一个同步方法，还有一个同步代码块。我们先通过javac编译成.class文件，再用javap查看其汇编指令，具体观察下如何运作的。 汇编指令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960Compiled from &quot;SynchronizedTest.java&quot;public class SynchronizedTest &#123;int count;public SynchronizedTest();Code:0: aload_01: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V4: aload_05: iconst_06: putfield #2 // Field count:I9: returnpublic void normalMethod();Code:0: aload_01: dup2: getfield #2 // Field count:I5: iconst_16: iadd7: putfield #2 // Field count:I10: returnpublic synchronized void syncMethod();Code:0: aload_01: dup2: getfield #2 // Field count:I5: iconst_16: iadd7: putfield #2 // Field count:I10: returnpublic void syncCodeBlock();Code:0: aload_01: dup2: astore_13: monitorenter4: aload_05: dup6: getfield #2 // Field count:I9: iconst_110: iadd11: putfield #2 // Field count:I14: aload_115: monitorexit16: goto 2419: astore_220: aload_121: monitorexit22: aload_223: athrow24: returnException table:from to target type4 16 19 any19 22 19 any&#125; 主要关注第24～32行和第34～54行；可以很快的发现，同步方法其实和普通方法在字节码角度去看是没有任何区别的；但是，同步方法块中，是通过显式的monitorenter和monitorexit，JVM在执行时候便会进行同步处理，具体如何操作我们稍作讲解； 同步方法到底是怎么操作的呢？其实，了解过Class文件的同学应该知道Class文件中有方法表，方法表定义了每个方法信息method_info，该结构体中有个access_flags字段记录方法的访问标记，其中synchronized就会被记录。当方法被调用的时候发现access_flags定义了synchronized标记，如果是静态方法则针对该Class对象进行同步处理，如果是实例方法则针对实例对象进行同步处理； ObjectMonitor——管程在JVM中的实现上一小节中说到了，JVM如何知道程序员定义的方法或者代码块需要同步处理；那么说到JVM同步处理，就必须要知道ObjectMonitor结构体了。 管程在JVM中的具体实现是ObjectMonitor，可以参考HotSpot源码：ObjectMonitor.hpp；主要的属性包含： _entryList：希望进入管程monitor对象，处于blocked状态的线程； _waitSet：已经获得过锁，但是在条件队列上处于wait状态的线程； ObjectMonitor图解，图片源于百度搜索结果 当线程处理到同步逻辑时候，会进入同步对象的ObjectMonitor中。线程会enter放置到EntrySet集合中。当线程acquire到资源后，就进入临界区中；如果需要条件等待，则release锁并放置到WaitSet集合中等待再次被唤醒，重新acquire进入临界区；如果逻辑处理完成，便会release锁，并退出临界区。 Mutex LockObjectMonitor只是高级语言写出的结构体，在转换成010101二进制码给CPU处理时，硬件是如何保证线程间的互斥性呢？ 我们先引出操作系统中的Mutex Lock。这个锁是具有排他性的，所有线程中只会有一个线程才能获取到；没有获取到锁的线程可能会进入睡眠，这样就会存在线程上下文切换的小号。ObjectMonitor就是基于此实现的。操作系统的MutexLock是怎么实现的，笔者也不是特别清楚，就不随意发言了。有兴趣的同学可以研究下，顺便留言和大家分享下呢！或者如果有高手的话，还请多多指教！ 从硬件的角度看互斥性的实现，就是需要保证多个CPU核之间的执行唯一性。MESI协议、总线锁，都是实现互斥的关键技术。 synchronized锁优化上面介绍了管程的概念以及实现，相信大家都有了一定的认知了。但是！我这边提出一个场景： 只有少量的线程抢占共享资源 因为上面说到是由MutexLock实现的，不论多少个线程，哪怕只有一个线程在抢占时，也是需要锁住CPU核，从而造成资源浪费；所以MutexLock称之为重量级锁。Java 1.6后引入了偏向锁和轻量级锁，线程在较少的抢占情况下，无需通过MutexLock来获取锁； 对象头一个Java对象在JVM中，分成三个区域：对象头、实例数据、对齐填充； 实例数据：4个字节对齐，存储类的数据，包括父类属性，如果是数组还包括数据长度； 对象头：一部分存储自身运行时数据，如GC年代、哈希码、锁信息等，在32/64位机器占用32/64位，官方称为Mark Word；另一部分则存储对象类型数据的指针，数组对象还需存储数组的长度； 填充数据：JVM要求对象起始地址必须是8字节的倍数，仅为了对齐； JVM为了空间效率，Mark Word设计成非固定数据结构，以便存储更多数据；具体如下: MarkWord不同形式，图片源于网络 锁的升级和撤销上面其实已经说过，synchronized在未优化前，不论何种场景都是按照重量级锁进行互斥的；Java1.6后，JVM会根据不同的场景做了优化以及升级； 上小节的图片中可以看到MarkWord会存在四种状态：无锁、偏向锁、轻量级锁以及重量级锁，按照这个顺序不断升级锁来适应不同的场景。注：synchronized不能降级！ 无锁升级成偏向锁如果当前只有一个线程运行，此时只会加上偏向锁。具体过程是: 线程会先查看MarkWord的锁标记位和偏向锁标记位，如果是无锁状态，则当前线程可获得偏向锁； 通过CAS无锁的方式将MarkWord的偏向锁标记位修改为1，以及赋值当前线程ID； 偏向锁撤销，升级成轻量级锁如上，已经有一个线程A获得了偏向锁，此时又有一个线程B来获取锁： 线程B会先查看MarkWord的锁标记位和偏向锁标记位，发现是偏向锁状态； 判断偏向锁线程id是否为自己，如果是则已经获取；如果不是自己，则尝试通过CAS设置MarkWord，则需要发起撤销偏向锁； 暂停线程A，解偏向锁并将线程id置为空，再恢复线程B；（此阶段会STW, 撤销完后MarkWord此时无锁状态） 线程A和B会竞争轻量级锁，都会先在自己的线程栈上分配空间并复制对象头的MarkWord作为Displaced MarkWord，A、B通过CAS无锁方式将对象头的Markword指向自己栈空间； 只有一个线程能成功，该线程获得轻量级锁； 轻量级锁撤销，升级成重量级锁假设线程A获得轻量级锁，线程B未获取到； 线程B会继续CAS尝试将Markword指向自己的DisplacedMarkWord；当尝试到一定次数后仍失败，则将锁膨胀修改成重量级锁，阻塞住； 线程A会将对象头的MarkWord通过CAS修改恢复，释放锁，并唤醒线程B； 此时对象头的锁标记位就是10了，即重量级锁。A和B就需要进行介绍的重量级锁的竞争了；","categories":[],"tags":[{"name":"Java面试复习","slug":"Java面试复习","permalink":"http://joruachan.cn/tags/Java%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"},{"name":"多线程","slug":"多线程","permalink":"http://joruachan.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"author":"Jorua"},{"title":"MySQL统计信息研究","slug":"mysql-stats-info-explore","date":"2021-01-30T16:00:00.000Z","updated":"2021-02-01T16:00:00.000Z","comments":true,"path":"2021-01-31/mysql-stats-info-explore/","link":"","permalink":"http://joruachan.cn/2021-01-31/mysql-stats-info-explore/","excerpt":"","text":"阅读此文，最好事先了解MySQL对SQL语句的执行流程。笔者后续会针对性地补充相关内容，敬请期待！ 统计信息简介了解过SQL语句执行流程的童鞋应该都知道，查询优化器会根据统计信息和代价模型计算每个执行计划的成本大小，从而选择成本最小的执行计划；总而言之，统计信息是决定最终explain所见的执行计划的一个重要因素！ 统计信息分成非持久化统计信息和持久化统计信息；统计信息可由MySQL专门的后台线程dict_stats_thread自动触发更新，也可手动更新； 非持久化统计信息非持久化的统计信息是存在内存中的，数据库重启后会丢失；所以在重启时，大量表会更新统计信息，会对数据库实例造成较大影响； 开启方式：全局变量，针对全局表的默认设置，INNODB_STATS_PERSISTENT = OFF; 或者只针对某个表，在create或者alter时候设置STATS_PERSISTENT = 0; 自动更新 (主要) 场景： 1. 距离上次统计信息更新，表中1/16的数据被修改； 2. innodb_stats_on_metadata=ON的情况下，SHOW TABLE STATUS，SHOW INDEX以及查询INFORMATION_SCHEMA下的TABLES或STATISTICS； 上面说到，非持久化统计信息在数据库重启的时候会大量更新，对数据库造成影响，所以生产上几乎不会采用这种方案； 持久化统计信息持久化的统计信息是存在物理表中的，数据库重启后不会丢失；具体的表为：mysql库下的innodb_index_stats和innodb_table_stats； 开启方式：5.6.6版本后MySQL默认开启持久化统计信，即INNODB_STATS_PERSISTENT = ON； 自动更新（主要）场景： 1. 距离上次统计信息更新，表中1/10的数据被修改； 2. 新建索引，重建索引，truncate； innodb_table_stats表先看下innodb_table_stats表的DDL innodb_table_stats DDL123456789CREATE TABLE `innodb_table_stats` ( `database_name` varchar(64) COLLATE utf8_bin NOT NULL, `table_name` varchar(64) COLLATE utf8_bin NOT NULL, `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `n_rows` bigint(20) unsigned NOT NULL, `clustered_index_size` bigint(20) unsigned NOT NULL, `sum_of_other_index_sizes` bigint(20) unsigned NOT NULL, PRIMARY KEY (`database_name`,`table_name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin STATS_PERSISTENT=0 字段介绍 database_name: 数据库名称； table_name: 表名称； last_update: 更新时间； n_rows: 表数据的总行数； clustered_index_size: 聚簇索引的总页数； sum_of_other_index_sizes: 非聚簇索引的总页数； 引申介绍聚簇索引：innodb引擎，必须有且只有一个主键，这种索引是将数据和索引存储在一起的，只要找到索引的位置就可以找到行数据；但是通过辅助索引需要经历两次查询，先通过辅助索引找到主键位置，再通过聚簇索引找到数据； 非聚簇索引：myisam引擎，索引和数据是分开存储的，索引的叶子节点指向数据行地址；辅助索引和主键索引以及数据文件都是独立的；myisam通过key_buffer把索引先缓存到内存中，当通过索引访问数据时，在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因； innodb_index_stats表先看下innodb_index_stats表的DDL innodb_index_stats DDL1234567891011CREATE TABLE `innodb_index_stats` ( `database_name` varchar(64) COLLATE utf8_bin NOT NULL, `table_name` varchar(64) COLLATE utf8_bin NOT NULL, `index_name` varchar(64) COLLATE utf8_bin NOT NULL, `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `stat_name` varchar(64) COLLATE utf8_bin NOT NULL, `stat_value` bigint(20) unsigned NOT NULL, `sample_size` bigint(20) unsigned DEFAULT NULL, `stat_description` varchar(1024) COLLATE utf8_bin NOT NULL, PRIMARY KEY (`database_name`,`table_name`,`index_name`,`stat_name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin STATS_PERSISTENT=0 字段介绍 database_name: 数据库名称； table_name: 表名称； index_name: 索引名称； last_update: 更新时间； stat_name: 统计信息名； stat_value: 统计信息值； sample_size: 采样大小； stat_description: 类型说明； 统计项说明如果翻看innodb_index_stats表数据，你会发现每个索引都会有多个统计项(stat_name)；主要如下： stat_name统计项 stat_value含义 size 索引的页数量 n_leaf_pages 叶子节点的数量 n_diff_pfxNN 索引上唯一值的数量；因为索引可能是多列，所以NN表示从左递增的列组合唯一值的数量；注意如果是普通索引除去自身索引列的统计，还会加上唯一索引列进行统计； 了解stat_name和stat_value的具体含义，可以在解决或者优化慢查询问题上，起到一定的作用。如果统计值远小于实际值，查询优化器基本上不会选择该索引进行查询检索； n_diff_pfxNN举例说明假设表有字段：a、b、c、d、e，唯一索引：uix_a_b_c(a, b, c)， 普通索引：idx_d_e(d, e)；针对唯一索引uix_a_b_c则会有统计项： 1. n_diff_pfx01表示列a上的唯一值数量；2. n_diff_pfx02表示a,b两列组合的唯一值数量；3. n_diff_pfx03表示a,b,c三列组合的唯一值数量；针对普通索引：idx_d_e则会有统计项： 1. n_diff_pfx01表示d列上的唯一值数量；2. n_diff_pfx02表示d, e两列组合的唯一值数量；3. n_diff_pfx03表示d, e, a三列组合的唯一值数量；3. n_diff_pfx04表示d, e, a, b四列组合的唯一值数量；3. n_diff_pfx05表示d, e, a, b, c五列组合的唯一值数量； 手动更新统计信息执行ANALYZE TABLE table_name。注意：执行此语句时，需要保证用户拥有select和insert的权限；执行时，会持有innodb表的readonly锁，从而会短暂导致表的写入、更新、删除操作； 统计信息不准确，怎么办？如我的随笔中，《什么？MySQL还有统计信息一说？》一文中，有说到生产环境更新了索引，经过执行计划的查看，查询优化器并没有使用新建的索引； 运维查看了统计信息后，发现统计信息不准确，便执行ANALYZE TABLE table_name刷新了统计信息，便可以正常使用索引查询了。 所以，我们来整理下，如果发现索引没有正常被使用，发现和解决问题的大致思路。如有不适当的地方，欢迎大家留言点拨和斧正！ 第一步：检查索引是否建立起来，如果这步都漏了，是得好好反思下了； 第二步：索引正常建立，查询还是很慢，则查看执行计划，判断索引是否正常被使用；如果没被使用则走第三步，被使用了则走第四步； 第三步：索引正常建立，但是执行计划没有选择该索引；则查看统计信息，如果统计信息异常，则执行ANALYZE TABLE table_name刷新统计信息；还没有恢复，则调大采样变量大小； 第四步：索引正常建立，执行计划也选择了该索引，在SQL无问题的前提下需要考虑设计方面； 注： 以上步骤建立在SQL没有问题的情况之上！","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://joruachan.cn/tags/MySQL/"}],"author":"Jorua"},{"title":"什么？MySQL还有统计信息一说？","slug":"mysql-stats-info","date":"2021-01-29T16:00:00.000Z","updated":"2021-08-25T10:52:55.651Z","comments":true,"path":"2021-01-30/mysql-stats-info/","link":"","permalink":"http://joruachan.cn/2021-01-30/mysql-stats-info/","excerpt":"","text":"笔者最近在项目上对现有表进行了结构优化，并对一个常用表添加了索引。可谓测试环境玩漂移，生产环境怕翻车啊。上线验证的那一刻，突然发现一个类似报表功能的查询SQL极慢！ 背景说明 故障简查 检查添加索引索引的SQL，查看SQL执行结果，检查DDL。一顿操作后，表象上没看出问题 比较执行计划 连接sit环境执行explain，发现没问题，索引正常用上的。在生产的dbms上执行explain，发现索引没有用上，join查询时全表扫描了 查看MySQL版本 sit和prd环境都是5.7.22版本，看样子也不是版本不同造成的 再次分析 既然MySQL版本也一样，DDL也一样，为啥执行计划就是不一样呢？一边猜测着是不是有什么缓存，一边为了节约发布时间，让运维帮忙先把索引删掉再重新添加下 问题暴露 也许是运维对问题的普遍性或者敏感性，过了两三分钟，没对索引操作便通知我们好了！心里便纳了闷了，运维大牛确实牛啊！咨询了一番，便引出今天的话题了：刷新了统计信息 统计信息研究笔者学识浅薄，未曾了解“统计信息”。特此奉上，统计信息研究！大神勿喷！ 本文为随笔，具体的研究文章见： MySQL统计信息研究https://joruachan.cn/2021-01-31/mysql-stats-info-explore/","categories":[{"name":"随笔","slug":"随笔","permalink":"http://joruachan.cn/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://joruachan.cn/tags/MySQL/"}],"author":"Jorua"},{"title":"纪实:nodejs+hexo+volantis快速构建个人Blog","slug":"fast-build-blog","date":"2021-01-16T16:00:00.000Z","updated":"2021-08-25T10:52:55.651Z","comments":true,"path":"2021-01-17/fast-build-blog/","link":"","permalink":"http://joruachan.cn/2021-01-17/fast-build-blog/","excerpt":"","text":"即使身为一个钢铁直男的技术人，能拥有一个分享自己技术心得和生活分享的小窝，想必是每个技术人都考虑过的事情吧! 笔者这就告诉你一个秘密：只需执行几行命令，改点配置，一个端庄不失典雅的博客网站就能生成好！ 搭建环境简介nodejs + hexo; nodejs的安装本文不再介绍，不熟悉的同学可前往nodejs官网学习并安装；本站选用hexo的volantis主题介绍建站的， hexo提供了330款主题，如有需要，可前往查看其他主题 NodeJshttps://nodejs.org/en/ Hexohttps://hexo.io/ Volantishttps://volantis.js.org/ hexo简介hexo 自称为：快速、简洁且高效的博客框架。 笔者用起来确实还可以，大概介绍下几个特性： 提供了不同的layout，可将文章存为草稿，需要时publish即可； 可维护全局的数据，在source/_data文件夹下添加yaml文件，通过site.data获取； 可指定文件的特有变量，通过Front-matter实现； 支持模板，在scaffolds文件夹下可自定义模板，并进行发布； 支持标签插件，可以在文章文件中使用标签%%来插入特定内容； 提供命令行操作，如：hexo init初始化项目、hexo new新建文章、hexo pulish发布草稿文件、hexo generate生成静态文件、hexo server启动服务器； hexo搭建博客步骤 前提是必须安装好git和nodejs； 执行 “npm install -g hexo-cli”，安装好hexo； 选定文件夹，通过 “hexo init $folder” 初始化一个名为 $folder 的文件夹； cd $folder, 再执行npm install，至此hexo的博客框架已经搭建完成！ 完成上述步骤后，可执行hexo server, 访问http://localhost:4000, 会发现一个HelloWorld页面已经可以访问！ 选用volantis主题 设置项目使用的主题: 项目根目录下的_config.yml文件中设置 theme: volantis; 如果Hexo版本在5.0.2及以上，可以直接通过npm i hexo-theme-volantis进行安装；笔者为了项目的可读性，采用了源代码拷贝到theme文件夹的方案（记得删除.git文件夹,否则git提交时会出问题!） 按照依赖的插件：npm i hexo-generator-search hexo-generator-json-content(站内搜索)，npm i hexo-renderer-stylus（Stylus 渲染器） 完成上述步骤后执行hexo server, 访问http://localhost:4000, 是不是发现端庄不失典雅的博客网站已经完成了！ 尝试新建文章执行 hexo new post $newPostName，会在_post文件夹下新建一个名为$newPostName的md文件，一个新的文章便建立完成。 这时你只需要关注你的博文输出即可啦！ 发布至GitHub Pages如果你期望能通过GitHub Pages来访问你的博客网站，做如下几步： 通过GitHub新建一个repository，名为：&lt;你的 GitHub 用户名&gt;.github.io； 本地检出该repository； 在博客源码的项目中执行命令：hexo generate –deploy，会生成public文件夹，该文件夹里便是博客所有的静态页面文件； 将public文件夹中的文件全部拷贝到新建repository的master分支下； 将master文件推送至远程master分支即可！ 静待一会，访问：http://&lt;你的 GitHub 用户名&gt;.github.io便能访问你自定义的博客了！ 如果你有自己的域名，可以在域名解析配置成 记录类型：CNAME，记录值：&lt;你的 GitHub 用户名&gt;.github.io。 注意了！！！ 此时还需要在GitHub Page项目中根目录下加上名为CNAME的文件，文件内容为你自己的域名。 正如你看到的，搭建一个个人博客网站就是如此便捷！ 如果你喜欢的话，点个赞，分享分享下吧！谢谢~","categories":[],"tags":[],"author":"Jorua"}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://joruachan.cn/categories/%E9%9A%8F%E7%AC%94/"},{"name":"随便聊聊","slug":"随便聊聊","permalink":"http://joruachan.cn/categories/%E9%9A%8F%E4%BE%BF%E8%81%8A%E8%81%8A/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://joruachan.cn/tags/%E6%A1%86%E6%9E%B6/"},{"name":"高并发","slug":"高并发","permalink":"http://joruachan.cn/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"数据结构","slug":"数据结构","permalink":"http://joruachan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"除了工作以外的","slug":"除了工作以外的","permalink":"http://joruachan.cn/tags/%E9%99%A4%E4%BA%86%E5%B7%A5%E4%BD%9C%E4%BB%A5%E5%A4%96%E7%9A%84/"},{"name":"Java面试复习","slug":"Java面试复习","permalink":"http://joruachan.cn/tags/Java%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"},{"name":"多线程","slug":"多线程","permalink":"http://joruachan.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"MySQL","slug":"MySQL","permalink":"http://joruachan.cn/tags/MySQL/"}]}