{"meta":{"title":"JoruaChan技术博客","subtitle":"永远不甘于现状","description":"","author":"JoruaChan","url":"http://joruachan.cn","root":"/"},"pages":[{"title":"","date":"2021-09-09T16:25:46.916Z","updated":"2021-09-09T16:25:46.916Z","comments":false,"path":"404.html","permalink":"http://joruachan.cn/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-09-09T15:19:44.131Z","updated":"2021-09-09T15:19:44.131Z","comments":true,"path":"about/index.html","permalink":"http://joruachan.cn/about/index.html","excerpt":"","text":"「 In me the tiger sniffs the rose;(心有猛虎，细嗅蔷薇) 」 —— Siegfried Sassoon（译自余光中） 如果此时你翻到此页，我是否可以自信地问你一声：是我的博客某方面吸引到你了吧！哈哈，笔者开了个玩笑，一直想要搭建个属于自己的博客，苦于各种原因，或者说自己没有静下心来落实这件事。 在这个“阳光明媚”的夜晚，我坚定地告诉你们，我肯定会努力建设本博客站的！不仅博客，包括我的GitHub项目，我会争取每天、每周更新、发布的！ 博客介绍我简单介绍下，本博客网站的主要建设思路，内容展示区域主要分成首页、随笔、闲谈和归档。 首页，是想分享个人觉得不错的文章或者趣事； 随笔，可以看成技术相关的笔记本，文章内容偏于生产事件、学习发现而引出的技术讨论点； 闲谈，每个人都会有自己的生活，我也想将我的事情或者心里话分享给老铁们； 归档，将我编写或转载的所有文章集中归档于此，方便查阅； 可能你看过我的某篇文章，想重新翻阅，但是你没有收藏。不要慌，导航栏看到没有？”Search Something…”看到没有？对，敲入你的关键字，让我帮你想！ 更新日记来吧，翻开日记本！ 记录博客建设 2021-09-07 重启博客计划 稳定了，心也跟着安定了。经历了太多，重拾博客！ 2021-01-26 域名备案完成 joruachan.cn 终于有了专属于我自己的域名啦，撒花！✿✿ヽ(°▽°)ノ✿ 2021-01-17 初步搭建 是时候觉得应该搭建一个博客了，之前了解过hexo，但是一直没有着手实践；选择了Volantis主题，实践完后，体验非常好。操作简单、搭建方便，并且博客整体样式显得很年轻化，适合我们年老心未老的老年人！哈哈，坚持写作、记录技术！期待我的博客能够越来越火！希望你们能挺我起来！ 最后我相信每个博主建设博客网站，除了分享知识和生活，肯定还想多交朋友。如果我的博客能得到你的芳心， 点赞收藏不要紧张哦！ 另外，如果您有任何建议或者疑问，欢迎在此页进行留言！"},{"title":"更新日记 and 计划","date":"2021-09-23T16:04:37.016Z","updated":"2021-09-23T16:04:37.016Z","comments":false,"path":"changelog/index.html","permalink":"http://joruachan.cn/changelog/index.html","excerpt":"","text":"2021-09-30 (plan) debug代码——Spring代理 2021-09-23 再回首JDK 2021-09-13 界面优化 完善 《史上最全synchronized关键字总结》 2021-09-08 界面优化增加”闲谈”区域","author":"Jorua"},{"title":"","date":"2021-09-08T15:26:46.608Z","updated":"2021-09-08T15:26:46.608Z","comments":true,"path":"chat/index.html","permalink":"http://joruachan.cn/chat/index.html","excerpt":"","text":""},{"title":"","date":"2021-08-25T10:52:55.652Z","updated":"2021-08-25T10:52:55.652Z","comments":true,"path":"essay/index.html","permalink":"http://joruachan.cn/essay/index.html","excerpt":"","text":""}],"posts":[{"title":"《见识》读后感","slug":"after-reading-jianshi","date":"2022-01-23T15:36:01.000Z","updated":"2022-01-24T16:29:47.465Z","comments":true,"path":"2022-01-23/after-reading-jianshi/","link":"","permalink":"http://joruachan.cn/2022-01-23/after-reading-jianshi/","excerpt":"","text":"第二章 人生需要做减法西瓜与芝麻 社会上太多捡芝麻的人，不仅时间利用得没有效率，而且渐渐习惯于非常低层次的追求！如花大量的时间或精力来捡芝麻； 公司和个人一样，专注西瓜去捡，目光放得更长远； 聚焦”练就捡西瓜的能力”，从同事中脱颖而出； 致力于捡西瓜，那就要耐得住寂寞； 生也有涯，知也无涯 庄子在《养生主》开篇讲：”吾生也有涯，而知也无涯，以有涯随无涯，殆矣。已而为知者，殆而已矣。”； 跳出原有的思维定式，考虑如何少做事，而不是让自己更忙碌； 初创公司也是如此，小公司资源有限，必须将人力集中到一个点上，学会做减法；","categories":[],"tags":[{"name":"除了工作以外的","slug":"除了工作以外的","permalink":"http://joruachan.cn/tags/%E9%99%A4%E4%BA%86%E5%B7%A5%E4%BD%9C%E4%BB%A5%E5%A4%96%E7%9A%84/"},{"name":"《见识》","slug":"《见识》","permalink":"http://joruachan.cn/tags/%E3%80%8A%E8%A7%81%E8%AF%86%E3%80%8B/"}],"author":"Jorua"},{"title":"Netty日记","slug":"netty-daily","date":"2021-11-06T16:00:00.000Z","updated":"2021-11-30T15:02:34.902Z","comments":true,"path":"2021-11-07/netty-daily/","link":"","permalink":"http://joruachan.cn/2021-11-07/netty-daily/","excerpt":"","text":"2021年11月6日Linux I/O 只有内核能与外设交互，且内核将外设的操作都视作文件操作；对文件的操作，内核都会返回fd文件描述符；对socket的读写也有对应的socket fd； 五种IO模型：阻塞IO、非阻塞IO、IO复用、信号驱动、异步IO； 五种IO模型总结： 所有IO操作，都包含：内核等待数据准备好、内核拷贝数据到用户空间； 除了异步IO，其他四种模型在拷贝期间，进程都是阻塞的； 阻塞IO：两步期间，进程阻塞直到拷贝完成，期间进程不能做其他事； 非阻塞IO：数据准备好前，会主动轮询内核是否准备好数据了，进程虽然未阻塞，但是也干不了其他事情；拷贝期间进程阻塞； IO复用：复用的意义在于，将多个IO请求汇总到一个select阻塞请求上，而不需要每个进程都阻塞；select请求会阻塞遍历所有事件，直至找到完成的事件；可以理解成通过多个进程间的协作完成IO； 信号驱动：当数据准备好的时候，内核向用户进程发送SIGIO信号通知；拷贝期间会阻塞； 异步IO：用户进程全程无需关心，发起请求后，内核开始等待数据准备好，将数据从内核拷贝到用户空间后，向用户进程递交信号； 2021年11月7日Linux对IO复用的支持 支持IO复用的函数调用：select、pselect、poll、epoll; select：通过轮询fd, 来查看IO是否就绪；缺点：单个进程下只支持1024个fd，需要轮询所有的fd； epoll：select的替代方案；优点： 无fd限制，支持OS的最大文件句柄数； 只对注册的、活跃的fd遍历查看是否就绪； fd就绪的消息通知使用mmap内存共享，减少内核拷贝到用户空间的开销； 2021年11月15日IO编程范式回味下在C/S模式下，网络IO编程的常用规范； 传统BIO一个客户端的请求，要创建一个线程处理；Acceptor接收到client的请求后，创建一个线程，并将socket对象传递进行链接建立、处理请求并返回； 弊端：服务器资源有限，只能支持并发量很低的场景； 伪异步IO利用线程池技术，使得请求和线程的关系为M:N，通过线程池灵活调整线程资源，防止线程耗尽；Acceptor接收到client的请求后，从线程池中取出一个可用线程，并将socket对象传递进行链接建立、处理请求并返回； 弊端：能避免线程耗尽，但是BIO的read和write方法都是阻塞的；当逻辑复杂的时候，处理时间较久，容易导致其他的线程排队阻塞；整体看，处理速度由IO速度、网络传输速度绝对，而处理速度直接决定了在高并发情况下的响应速度；所以，该方案支持一定并发量的请求，但是不能支持高并发； NIOJava NIO主要由Buffer缓冲池、Channel通道、Selector多路复用器组成；将Channel关心的事件注册到Selector上；Channel上有事件时，Channel会就绪，Selector就能轮询出就绪的Channel事件；Channel上数据的读写都通过Buffer对象处理； 弊端：Java NIO基于epoll实现了IO多路复用，支持成千上万的并发量，但是代码量大、编程方式较复杂； AIOJava NIO提供了异步文件通道和异步套接字通道，可以实现真正的异步IO；通过CompletionHandler实现IO结束时的回调； 2021年11月30日获取时间的C/S，通过不同IO编程范式的代码实现案例，点击跳转；","categories":[],"tags":[{"name":"Netty","slug":"Netty","permalink":"http://joruachan.cn/tags/Netty/"},{"name":"Java面试复习","slug":"Java面试复习","permalink":"http://joruachan.cn/tags/Java%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"},{"name":"高并发","slug":"高并发","permalink":"http://joruachan.cn/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"}],"author":"Jorua"},{"title":"tcpdump初体验","slug":"tcpdump-essay","date":"2021-11-01T16:00:00.000Z","updated":"2021-11-03T16:29:38.117Z","comments":true,"path":"2021-11-02/tcpdump-essay/","link":"","permalink":"http://joruachan.cn/2021-11-02/tcpdump-essay/","excerpt":"","text":"tcpdump命令抓取包 使用下载安装好的Wireshark软件打开 分析过滤你需要的包","categories":[{"name":"随笔","slug":"随笔","permalink":"http://joruachan.cn/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://joruachan.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"抓包","slug":"抓包","permalink":"http://joruachan.cn/tags/%E6%8A%93%E5%8C%85/"}],"author":"Jorua"},{"title":"透彻理解RTP","slug":"rtp-introduction","date":"2021-10-21T16:00:00.000Z","updated":"2021-11-07T13:36:56.555Z","comments":true,"path":"2021-10-22/rtp-introduction/","link":"","permalink":"http://joruachan.cn/2021-10-22/rtp-introduction/","excerpt":"","text":"RTP——实时传输协议RTP（Real-time Transport Protocol），实时传输协议；RTP协议在RFC 3550文档中详细说明了在互联网上传递音频和视频的标准数据包格式。 它一开始被设计为一个多播协议，但后来被用在很多的单播应用中。RTP协议常用于流媒体系统、视频会议，使它成为IP电话产业的技术基础。 RTP协议通常是建立在UDP协议之上的，由于UDP面向数据报，是非可靠的，所以如果需要提高服务质量，则需要实现RTCP协议；通常RTP和RTCP是相邻的两个端口，偶数端口是RTP通信，偶数+1的奇数端口是RTCP通信； 应用场景 多播音频会议，通过一个多播地址和一对端口（一个传输RTP，一个传输RTCP）来实现； 音视频会议，利用两个RTP会话传输，一个传视频数据，一个传音频数据。每个会话对应的RTCP都有CNAME，根据CNAME获取对应的音视频，并根据计时信息实现音视频同步； 翻译器，RTP级的中继系统。翻译器用在通过IP多播不能直接到达的用户区，例如发送者和接收者之间存在防火墙； 混合器，RTP级的中继系统。当与会者能接收的音频编码格式不一样，比如有一个与会者通过一条低速链路接入到高速会议，这时就要使用混合器。在进入音频数据格式需要变化的网络前，混合器将来自一个源或多个源的音频包进行重构，并把重构后的多个音频合并，采用另一种音频编码进行编码后，再转发这个新的RTP包。从一个混合器出来的所有数据包要用混合器作为它们的SSRC（同步源）来识别，可以通过CSRC表（贡献源列表）确认谈话者； 协议分层传输层的子层图片源自网络 由上图可以看出，RTP被划分在传输层，它建立在UDP上。同UDP协议一样，为了实现其实时传输功能，RTP也有固定的封装形式。 开发者的”应用层”对于开发者来说，RTP如同应用层，因为RTP的实现需要开发者自行完成； 会话过程确认好传输地址当应用程序建立一个RTP会话时，应用程序将确定一对目的传输地址。目的传输地址由一个网络地址和一对端口组成，有两个端口：一个给RTP包，一个给RTCP包，使得RTP/RTCP数据能够正确发送。RTP数据发向偶数的UDP端口，而对应的控制信号RTCP数据发向相邻的奇数UDP端口（偶数的UDP端口＋1），这样就构成一个UDP端口对。 发送过程（接收过程相反） 接收如麦克风、摄像头等设备处理后，得到音视频编码后的流媒体信息码流（如H.263），封装成RTP数据包；RTCP从上层接收控制信息，封装成RTCP控制包; 将RTP数据包发往UDP端口对中偶数端口；RTCP将RTCP控制包发往UDP端口对中的接收端口; 数字音频信号处理数字音频处理的大方向是把我们所听到的声音以数字的方式记录下来，让计算机进行处理； 声音的产生和传播声音是通过震动产生的，震动迫使着空气震动，声音在空气中以波的形式传播，空气震动迫使你的耳骨膜震动，从而听到声音。 声音的记录震动耳骨膜能让人听到声音，那么用某个物体来模仿我们的耳骨膜来接收声音。例如：留声机中的振片就相当于人类的耳骨膜。 模拟信号&amp;数字信号声音的模拟信号是一段连续变化的波形；数字信号是将连续变化的波形转换成离散的数字信号；例如：振片接收的声音通过AD变换器转变为数字信号。 模拟信号转数字信号模拟信号到数字信号分为3步：采样，量化，编码； 采样：声音的模拟信号是一段连续的波形，数字信号是对波形采集样本得到的，一个点表示一个样本，采样所取得的数值是**音频的模拟电压值**； 量化：把电压值按照位数分级，每一区间统一为一个数值。用近似值来表示采样点的电压值，分级越多，数字音频质量就越高。通常电话语音用8位（256级）或CD用16位（65536级）； 编码：将模拟信号的量化值用二进制的方式进行编码； PCM脉冲编码调制，按照固定频率采样将声音从模拟信号转成数字信号，是 未经压缩的采样数据裸流 ；该数据没有文件头和尾；WAV格式就是在PCM文件前面加了一个长44字节的文件头； 两个重要指标 采样频率：数字信号对模拟信号的波形进行采样还原的频率，一定时间内采样频率越高，还原精度越高；（采样定理：用大于信号最高频率两倍的频率，对周期信号进行采样，可以保证完全重构原始信号） 量化精度：采样到的电压值会对该值量化成一个近似值；如果采取均匀量化，会导致信号失真，也就是弱信号恢复的差；所以，一般采用非均匀量化（弱信号密度大）或者提高量化精度； 编码将量化得到的二进制数据进行压缩，即编码数据；一般采用的是样本内压缩，如将16it的样本数据压缩成8bit的PCM样本数据；主要用的压缩算法是a-law和mu-law； 调制编码好的数据调制了才能播放，调制器会根据下节介绍的相关信息进行调制播放； 计量单位和换算 声道数：单/立体； 样本位数：一个样本的二进制位数；4/8/16/32bit; 采样频率: 一秒钟采样的次数，8kHz/11.025kHz/22.05kHz/16kHz/37.8kHz/44.1kHz/48kHz； 比特率： 样本位数 * 采样频率 * 声道数 帧率：FPS，帧/秒，每秒钟刷新的帧数； Q：已知采样率16k，采样位宽16bit，单声道；求每帧的播放时间？每帧的数据大小？A: 帧率50，则每帧播放时间：1s/50=20ms；再以每帧的时间20ms将1s等分50份，可得到每帧的样本数量：16000/50=320个；发送方压缩后每帧的数据大小：320*8bit=320byte；接收方解码后每帧640byte； RTP数据包RTP数据包组成RTP数据包 = UDP头部（8字节）+ RTP头部（标准12字节）+ Payload数据 RTP包最大长度MTU：链路层限制了数据帧的最大长度，以太网和802.3分别规定为1500字节和1492字节； 在TCP/IP层，需要依据MTU对数据报进行分片，保证每片的长度小于MTU；由此可知：TCP：1500 - 20（ip头）- 20（tcp头）- 4（RTP标志）= 1456UDP：1500 - 14（以太网头）- 20 (ip头）- 8 (udp头） = 1458 所以，一个RTP数据包最多承载 1458 - 12 = 1446 字节长的有效负载。将payload数据放入MTU为1500字节的网络上，标准的12字节长的RTP头部数据包(1458 字节)中。在实践中，如果通过Internet传输这些流量，这些流量会被封装或跨不同的传输层传输，一般保持payload负载长度在 1400 字节以下以确保安全。 包的头部组成图片源自网络 版本号（V）：2比特，用来标志使用的RTP版本； 填充位（P）：1比特，如果该位置位的话，RTP包的尾部就包含附加的填充字节； 扩展位（X）：1比特，如果该位置位的话，RTP固定头部后面就跟有一个扩展头部； CSRC计数器（CC）：4比特，含有固定头部后面跟着的CSRC的数目； 标记位（M）：1比特，该位的解释由配置文档（Profile）来承担； 载荷类型（PT）：7比特，标识了RTP载荷的类型，接收端用合适的解码器去解码并播放； 序列号（SN）：16比特，发送方在每发送完一个RTP包后就将该域的值增加1，接收方可以由该域检测包的丢失及恢复包序列，序列号的初始值是随机的； 时间戳：32比特，记录了该包中数据的第一个字节的采样时刻。在一次会话开始时，时间戳初始化成一个初始值。即使在没有信号发送时，时间戳的数值也要随时间而不断地增加（时间在流逝嘛）。时间戳是去除抖动和实现同步不可缺少的； 同步源标识符(SSRC)：32比特，同步源就是指RTP包流的来源，在同一个RTP会话中不能有两个相同的SSRC值，该标识符是随机选取的RFC1889推荐了MD5随机算法； 贡献源列表（CSRC List）：0～15项，每项32比特，用来标志对一个RTP混合器产生的新包有贡献的所有RTP包的源。由混合器将这些有贡献的SSRC标识符插入表中。SSRC标识符都被列出来，以便接收端能正确指出交谈双方的身份。 整理时间有限，还未整理完全，后续补充跟进~~~","categories":[],"tags":[{"name":"RTP","slug":"RTP","permalink":"http://joruachan.cn/tags/RTP/"},{"name":"网络协议","slug":"网络协议","permalink":"http://joruachan.cn/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://joruachan.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"author":"Jorua"},{"title":"再回首JDK","slug":"look-back-jdk","date":"2021-09-22T16:00:00.000Z","updated":"2021-09-23T16:03:09.636Z","comments":true,"path":"2021-09-23/look-back-jdk/","link":"","permalink":"http://joruachan.cn/2021-09-23/look-back-jdk/","excerpt":"","text":"如果你是刚要被Java军训的新兵，可有几时对环境搭建而不知所措？又如若你是驰骋Java战场多年的老将，可曾拿起陪伴你许久的82年的JDK回味一番？今天我们就来道一道JDK，重新来认识认识这个既熟悉又陌生的伙伴。 既然要唠唠JDK，首先想到的，肯定是要了解下都是谁来推进Java和JDK发展的。 Java发展的会议与组织说起Java的起源必定要提起Sun公司，由其发起了专属于Java的JavaOne会议。不过Sun公司被Oracle收购后，JavaOne会议同Oracle先前的Oracle OpenWorld会议并成了Oracle Code One会议，并且会议内容也不再单纯讨论Java的发展。另外还有JCP（Java Community Process）是个开放性的国际技术标准组织，职责是发展和更新Java 技术规范，由其推出了大量Java相关技术规范JSR，具体可点此查看。JCP的运作方式是由个人或者厂商提出JSR规范提案，再有JCP委员会的成员投票表决是否采用。其弊端是JCP委员会还是主要由厂商组成，这些规范可能更偏向于厂商的利益，而非大众的利益。 JDK版本我们要知道Java应用开发并不是只有常接触的移动端 、服务端的应用开发。Sun公司根据不同业务领域方向分成了四个JDK版本： Java Card，主要是以具有安全防护性的方式来执行小型的Java Applet，广泛运用在SIM卡、提款卡上； Java SE，前称J2SE。Java的标准版，为JavaEE和JavaME提供了基础类库以及能力。也是我们安装部署Java环境最基础的版本； Java EE，前称J2EE。针对企业级应用的加强版。主要涉及的技术：JDBC、EJB（被Spring遮住了光芒）、Servlet、RMI、JNDI、JMS、JPA、JTS等。Java 10版本以后被Oracle公司放弃，捐献给了Eclipse基金会，并后成为Jakarta EE; Java ME，前称J2ME。主要用于移动设备、嵌入式设备上的java应用程序； Oracle JDK vs Open JDKOpen JDK现已作为Java版本迭代的发展标准，并且开源。而Oracle JDK只不过是Open JDK的具体实现，不完全对外开源。 至于它俩的区别，下面的列表基本列出： Oracle JDK Open JDK 起源时间 JDK1.0，1996年1月发行 OpenJDK 6（基于Java SE 7），2007年发行 代码协议 新的OTN协议，2019年1月之后发布的Oracle JDK 8更新将无法用于商业 GPLv2+CE 发行周期 JDK6及之前大约每两年一版本，6至7五年，7至8、8至9三年;JDK10及以后均6个月一个大版本；每3年一个LTS版本； OpenJDK 9及之前大约三年一个版本；OpenJDK 10及以后均6个月一个大版本； 支持时间 从JDK10起，每6个月一个大版本；从JDK11起，每3年一个LTS长期维护的版本； 从JDK10起，每6个月一个大版本；不发行LTS版本，只维护半年，也就是下个版本发布便不再维护。但是有其他顶级公司继续维护，如Red Hat OpenJDK，Liberica OpenJDK 商标 java商标拥有者 不可使用java 性能 响应能力、JVM性能更强，更稳定 —— 功能 Flight Recorder，Java Mission Control和Application Class-Data Sharing Font Renderer，但OpenJDK 11后也包含Oracle JDK的功能，还有ZGC; OpenJDK也会附带JMC开源，当前还在开发中 如果你们公司既想应用新特性，又没有授权的话，那就使用OpenJDK 11吧！毕竟Oracle的产品总监也说了，Oracle JDK是基于OpenJDK源代码构建的，OracleJDK和OpenJDK在Java 11后，功能基本保持一致。可见链接：Oracle JDK Releases for Java 11 and Later。 各版本特性及重要事件 JDK 1.0 JDK 1.0在1996年1月23日发布，Java语言有了第一个正式版本的运行环境； JDK 1.2 JDK 1.2，Sun公司正式将Java拆分成J2SE，J2EE和J2ME三大技术体系； JDK 1.6 JDK 1.6，终结了J2EE、J2SE、J2ME的命名方式，启用Java SE 6、JavaEE 6、Java ME 6的命名方式。与此同时，Sun公司宣布将对Java技术开源； JDK 7 JDK 7，Sun公司被Oracle公司收购，发布时间延期； JDK 8 JDK 8，Oracle启用JEP（JDK Enhancement Proposal）定义管理新版JDK发布的新特性，完成了JDK 7规划了但没有实现的功能，HotSpot移除掉永久代，吸收了JRockit的Java Mission Control监控工具等功能；8u201/202版本后，如果是用作商业用途，需要收费； JDK 9 JDK 9，jigsaw模块化、增强jshell、jlink、jhsdb等工具，并支持了91个JEP；此前均以特性驱动发行版本。9开始变成以时间驱动，发布周期为6个月一个大版本，3年一个 LTS版本； JDK 10 JDK 10，主要是JDK内部重构，只支持了12个JEP；Oracle公司抛弃Java EE，捐献给Eclipse基金会； JDK 11 JDK 11，推出了ZGC垃圾收集器（只支持64位的Linux机器），支持了17个JEP；第一个官宣的LTS发行版； JDK 12 JDK 12：推出非Oracle开发的Shen-andoah垃圾收集器，OracleJDK随后剔除了，存在于OpenJDK，支持了8个JEP； JDK 13 JDK 13：支持5个JEP； JDK 14 JDK 14：推出Windows和MacOS的ZGC垃圾收集器，支持16个JEP； . . . . . . 各版本具体的New Feature，大家可以直接上Oracle官网追溯。或者查看我推荐的两篇博文：博文1传送门、博文2传送门。我这里就不再赘述了，后面会开个专栏，去探索实践Java每个版本特性的实现。 解密JDK包JDK的运用，渗透到从事Java开发工作的各位的每一天，从开发到调试，再到发布和部署，以及上线后的运维都息息相关。相信在座的各位，一定有过疑问，jdk到底是怎么组成的？了解这些可能对我们的开发工作没有太多的作用，但是哪位又能预料明天和bug哪个先到呢，也许这就是你找到问题根因的地方！再不济，学习点知识，总不会有坏处！跟随我的脚步，一起看看JDK到底是怎么构成的吧！ 组成架构我们先来看下官方文档中Java SE版本JDK的组成架构图： 很直接地可以看出，最下面的Java HotSpot VM，是Java运行最基础的组件；Java SE API即我们日常编程使用的Java类库；JRE是Java应用程序运行的最小环境，其中包括了JVM，Java SE API类库和其他标准或非标准组件；JDK包含了JRE和一些Tool。Java8增加新特性Compact Profiles，是因为Java丰富的类库在小型应用中显得有些累赘，便将JRE分成了三种实现，compact1、compact2和compact3，具体的拆分情况如下，可见数字越大，包含的内容越多。在编译时，使用option: -profile，指定对应的实现方式即可。 JDK文件组成以windows环境的Java 8u261版本为例，针对JDK的组成架构进行解读。先来了解下解压或者安装完JDK的文件夹结构吧： bin目录中存放了开发过程的编译解释工具，如java.exe、javac.exe等，以及开发运维工作中常用的资源消耗统计等不同功能的辅助工具，如jmap.exe、jconsole.exe、jstat.exe等。 include目录下可以看到都是以.h结尾的文件，用来支持Java中用到的本地方法以及JVM调试程序接口用到的本地技术。 jre目录则是jdk运行的开发环境时使用的runtime，如jdk bin目录下的执行文件都是建立在这个jre文件夹的基础上 ！当然也是可以单纯用于Java编写的程序。需要说明的，如果存在期望依赖的jar包（如中间件的驱动程序），可以放置于jre的lib目录下的ext文件夹 。 lib目录是存放JDK bin目录下可执行文件依赖的jar包等，如常见的tools.jar； src.zip则是Java类库源码，主要包含rt.jar，以及程序启动器Launcher源码，主要功能是创建ExtClassLoader和AppClassLoader，根据配置创建SercurityManager，设置进程上下文类加载器； JVMOracle官网po出组成架构图最下面便是最基础、最重要的JVM技术，是在真实计算机上模拟虚拟的计算机功能。正是它的存在，才成就了“一次编译，多次运行”； Java8后提供了两种模式的VM，一种是Client，通常用于客户端应用程序，可以减少应用的启动时间和内存占用，一种是Server，会提升运行时执行速度；在jvm.cfg文件中第一个是默认实现，默认是-server KNOWN，KNOWN可设置成IGNORE，这只是表示相应的option是否启用。 此处列出两个Q&amp;A，这也是我最初接触JVM的疑问。 Q1：JVM作为Java程序最重要的组件，为什么文件夹里没有一个很明显的文件表示用于JVM的呢？ A1：JVM以动态库的形式存在，Windows上置于jre的bin文件夹下的server或者client文件夹里的jvm.dll。Linux上置于jre的lib文件下的/amd**/server或者/amd**/client文件夹下的libjvm.so。 Q2：JVM是怎么被加载并实例化的？ A2：JVM加载是通过java.exe来完成：首先通过launcher下的main函数创建JVM装载环境、配置，然后装载jvm.dll，装载完成后通过JNI本地调用接口找到JNI_CreateJavaVM的函数地址，然后调用函数去实例化JNIEnv对象：JVM，最后便通过JVM实例装载并处理class文件。代码调用顺序如下，童鞋可自行看下源码：main() &gt; JLI_Launch() &gt; CreateExecutionEnvironment() &gt; SetJvmEnvironment() &gt; LoadJavaVM() &gt; JVMInit() &gt; JavaMain() &gt; InitializeJVM() &gt; CreateJavaVM() [调用JNI接口] &gt; LoadMainClass() &gt; GetApplicationClass() ； 哦~~原来是这样啊！是不是对JVM进一步认识了呢？不过这才是皮毛，剩下的等我开个专题慢慢道来！还不赶紧关注我？ JRE 依赖包JRE运行所依赖的jar包，包含在/jre/lib和/jre/lib/ext文件夹下，如果有jar包希望作为JVM信任的Jar包第一时间加载，也可以直接将jar包置于/jre/lib/ext文件夹下。介绍下所有依赖的jar包： jar包 作用 access-bridge.jar Microsoft Windows操作系统的Java Access Bridge使基于Windows的辅助技术可以与Java Accessibility API进行交互； charsets.jar 扩展的字符集。rt.jar中sun.nio.cs包下为基础的字符集； cldrdata.jar 数据标准库，用于数据的国际化和本地化。可见：cldr官网； deploy.jar 用于部署应用的执行安装程序； dnsns.jar 处理DNS服务，暴露lookupAllHostAddr(),getHostByAddr()方法，用于InetAddress； jaccess.jar Java Accessibility Utilities实用程序类的一部分，可帮助辅助技术提供对实现Java Accessibility API的GUI工具包的访问； javaws.jar JNLP协议，支持Java Web Start应用，可以直接通过浏览器执行Java应用程序； jce.jar 扩展的加密包； jfr.jar Java飞行记录器，是JMC的一个重要组成部分，用于记录JVM和运行的Java程序的诊断数据、分析数据。对性能影响小于1%； jfxrt.jar JavaFX的运行时核心jar包，相当于rt.jar jfxswt.jar 为JavaFX和Swing提供兼容性操作 jsse.jar 用于验证SSL连接的jar localedata.jar 国际化的数据 management-agent.jar 只有MANIFEST.MF一个文件，用于VisualVM或者JConsole等工具的代理jar包；可查看实际应用介绍 nashorn.jar Java嵌入式的JS引擎，可以实现js与Java的相互调用，还可以使用jrunscript命令运行js； plugin.jar 用于各种使用场景的插件jar包 resources.jar 用于各种使用场景用到的静态资源，如.properites，.png，.css，.txt等文件 rt.jar Java的runtime运行时核心代码包 sunec.jar,sunjce_provider.jar, sunmscapi.jar,sunpkcs11.jar 加密相关的jar包 zipfs.jar 支持对zip压缩包文件操作 rt.jar介绍Java SE版本涉及的基础核心类库，源码则可以将jdk的src.zip解压后查看。但是并非rt.jar中的所有包都是有源码的。 具体API都可以在https://docs.oracle.com/javase/8/docs/api/index.html查看，或者下到电脑自行查看，不同版本的API直接将”/8/“变更成你需要的Java版本即可。 接下来介绍下组成架构图中Java SE规范除去UI Toolkits的模块以及功能。 模块 API规范 功能 lang and util java.lang.* java.util.* 提供几乎所有Java应用程序的基本功能 Math java.lang.Math java.lang.StrictMathjava.math Management java.lang.managementjava.util.logging.LoggingMXBeanjavax.managementcom.sun.managementcom.sun.tools.attachcom.sun.tools.jconsole 提供JVM、JConsole、JMX、日志等监控管理功能 Versioning java.lang.Classjava.lang.ClassLoaderjava.lang.Packagejava.lang.System 提供Class、Package管理功能 Ref Objects java.lang.ref 引用对象提供与GC有限交互功能 Reflection java.lang.reflect 反射提供从JVM中查看加载类、修改对象的功能 Collections 基于java.util.Collection的实现基于java.util.Map的实现 提供了功能强大、设计优秀的集合操作功能 Concurrency Utilities java.utl.concurrent 提供了强大且易扩展的高并发解决方法 JAR java.util.jarjava.net.JarURLConnection 提供了Jar文件的处理功能 Logging java.util.logging 提供对日志记录的处理和交互 Preferences API java.util.prefs 提供对用户和应用的首选项处理功能 Instrumentation java.lang.instrument 用于工具来检测Java编程语言应用程序 Regular Expressions java.util.regex 正则表达式 ZIP java.util.zip 用于读取和写入标准ZIP和GZIP文件格式 Input/Output java.iojava.niocom.sun.nio 提供针对文件和设备I/O处理的丰富功能 Serialization java.io 提供Java对象的序列化和反序列化功能 Networking java.netjavax.netcom.sun.netjdk.net等 提供用于网络处理的功能，包括寻址、连接、安全等 Security java.securityjavax.cryptojavax.rmi.ssljavax.xml.cryptojavax.smartcardiocom.sun.securityorg.ietf.jgss等 用于与安全相关的功能的API，如访问控制，数字签名，身份验证和授权，加密等 Internationalization java.util.spijava.util.Localejava.text.DecimalFormatSymbols等 支持开发国际化应用程序的API，可以在不进行工程更改的情况下适应各种语言和地区。 Beans java.beansjava.beans.beancontext 主要提高了交互性和可维护性，JavaBeans的长期持久性可以读写bean作为其属性值的文本表示形式 JMX javax.management Management Extension管理扩展，用于管理和监控资源使用 XML JAXP javax.xmlorg.w3c.domorg.xml.sax 用于处理XML文档和数据 JNI 用于编写Java本机方法并将Java虚拟机嵌入本机应用程序的标准编程接口，可以实现Java与其他语言的交互。推荐一篇介绍如何使用JNI的文章 Extension Mechanism 支持扩展，jar包置于/jdk/jre/lib/ext,二进制文件置于/jdk/jre/bin，JVM会作为可信任文件加载，不做安全检查。已弃用，未来版本删除此功能 Override Mechanism 除JCP外定义的Java API，可以覆盖成新版本作为认可标准版本。未来版本删除功能 IDL org.omg.CORBAorg.omg.CosNamingorg.omg.PortableServerorg.omg.PortableInterceptororg.omg.DynamicAny 使分布式、支持Web的Java应用可以基于IIOP协议透明地调用远程服务 JDBC java.sqljavax.sql 通用数据访问接口，需要驱动进行连接。如常用的mysql-connector-java.jar JNDI javax.naming 提供命名和目录功能，以通用方式访问各种服务。如Spring定义的jndi-lookup可以用于Wildfly部署的应用程序来建立数据库连接 RMI java.rmi 提供调用远程JVM中的Java对象的方法，使用对象序列化来封装和解析 RMI-IIOP org.omg.CORBAorg.omg.CosNamingorg.omg.PortableServerjavax.rmi 通过Internet Inter-ORB协议技术进行Java远程方法调用RMI编程模型可通过RMI API进行CORBA服务器和应用程序的编程。 Scripting javax.script 脚本引擎接口，可以实现动态脚本与java的交互，Java SE套件中含有nashorn引擎，可见nashorn.jar JDK提供的工具所有提供的工具按照类别分组情况如下，具体的使用方法可以下载JDK的文档查看。 基本工具 (appletviewer, extcheck, jar, java, javac, javadoc, javah, javap, jdb, jdeps,jaotc) 安全工具 (keytool, jarsigner, policytool, kinit, klist, ktab) 国际化工具 (native2ascii) RMI工具 (rmic, rmiregistry, rmid, serialver) Java IDL和RMI-IIOP工具 (tnameserv, idlj, orbd, servertool) 部署工具 (javapackager, pack200, unpack200) Java Web Start工具 (javaws) 故障排除，性能分析，监视和管理工具 (jcmd, jconsole, jmc, jvisualvm) Web服务工具 (schemagen, wsgen, wsimport, xjc) Java 9及以后上述的组成架构图，是基于Java 8的解析。在Java9前，由于之前JRE必须要整体部署运行，会造成一定程度不期望的性能影响或者资源消耗。Oracle公司针对这方面的考虑，在JCP组织上做了很多的工作，终于在Java 9上实现了模块化。 Java 9之前是通过不同的package和jar对功能做区分隔离，Java9后，可以通过不同的module进行隔离。 如果打开JDK 9后文件夹，你会发现jre文件夹不存在了，出现了新的文件夹：jmods。文件夹下面的每个文件都是一个组件，每个组件都会有一个module-info.class文件。打开文件你会发现，存在着类似nodejs等语言常用的关键字：用requires引入需要的组件、 用exports暴露的包名；其中java.base是最基础的模块，其他组件不需要显示requires。 12345678module java.sql &#123; requires transitive java.logging; requires transitive java.transaction.xa; requires transitive java.xml; exports java.sql; exports javax.sql; uses java.sql.Driver;&#125; 笔者也还未曾使用过Java 8以后的版本编写过项目，童鞋们有没有优秀的文章分享分享呢？ 总结通过上述的篇幅，我们可以知道： JVM在JRE(JDK)中是以动态链接库的形式存在的，windows中是jvm.dll，linux中是libjvm.so JDK 8有3种实现的compact JRE，数字越大，功能越丰富 组成架构图中的Java SE API部分，位于/jre/lib和/jre/lib/ext文件夹下jar包中 rt.jar包是Java SE最为核心的包 组成架构图中的Tools部分，位于jdk的bin目录下的可执行的二进制文件 JDK 9后 Java SE API不再是以jar形式存在，而是.jmod文件，针对不同的功能进行模块化 现在对JDK的组成结构到实际开发运用是否有了进一步理解呢？有疑问的地方，欢迎童鞋们留言讨论！","categories":[],"tags":[{"name":"JDK","slug":"JDK","permalink":"http://joruachan.cn/tags/JDK/"},{"name":"基础知识","slug":"基础知识","permalink":"http://joruachan.cn/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"author":"Jorua"},{"title":"disruptor初次见面","slug":"the-first-time-2-meet-disruptor","date":"2021-09-14T16:00:00.000Z","updated":"2021-09-15T15:22:33.038Z","comments":true,"path":"2021-09-15/the-first-time-2-meet-disruptor/","link":"","permalink":"http://joruachan.cn/2021-09-15/the-first-time-2-meet-disruptor/","excerpt":"","text":"每每复习Java数据结构时候，总感觉在队列中找不到一个适合高并发场景的队列。JDK提供的队列模型不尽人意，那么今天将要像大家简单介绍下： Disruptor，一个适用于多线程间高并发交换数据的有界队列； 简单说几点，就能体现Disruptor的神奇： 在并发情况下，普通的内存队列处理速度，和IO速度处于同一个数量级； 基于Disruptor开发的系统单线程能支撑每秒600万订单； 生产者消费者的环形队列，无锁； 怎么样，是不是魅力很大？确实，目前GitHub上已经有14k+的Star了。 大家可以先阅读下其GitHub站，以及文档。我会将Disruptor的详细说明列入博客计划。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://joruachan.cn/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"高并发","slug":"高并发","permalink":"http://joruachan.cn/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"框架","slug":"框架","permalink":"http://joruachan.cn/tags/%E6%A1%86%E6%9E%B6/"},{"name":"数据结构","slug":"数据结构","permalink":"http://joruachan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"Jorua"},{"title":"这是我的一半2021","slug":"half-of-2021","date":"2021-09-07T15:34:22.000Z","updated":"2021-09-08T15:25:26.088Z","comments":true,"path":"2021-09-07/half-of-2021/","link":"","permalink":"http://joruachan.cn/2021-09-07/half-of-2021/","excerpt":"","text":"这篇文章起笔时间，2021年9月7日晚上。 间隔上篇博文，又过去了5个多月。中间发生了很多事，似乎明白了很多，让我坚定了很多选择；但是似乎又增添了不少疑惑，疑惑那些打破我认知的事情。不要觉得我矫情，也许你们觉得很正常，于我来说，可能正在经历生活、职场等等方面的历练。 简单说下吧。 婚姻，我们在三年恋爱后，终于————我迎娶她成为了丈夫，她嫁给我成为了妻子；感谢有她，庆幸有她！ 新房，房子在婚姻上我认为是个必需品，媳妇和我花了不少时间、心思在装配上，完美收官让我们心满意足；愿家愈来愈好！ 离职，陪上家公司经历了一段最困难的时期，不舍归不舍，生活还是要继续；祝福它吧！ 新城市，朝钱看所以我换了城市，上午仍在家，下午奔至另一个城市，快节奏让我觉得哪哪都是陌生的；但愿新城市温柔点！ 新工作，在我第四年的工作经验情况下，让我时时自己问自己：原来你不知道的还是有这么多？当然更多的原因是没有接触过的业务；卷起来吧！ 2021不一般！带着憧憬，带着责任，全力以赴。当然现在，所有的一切都逐渐稳定了。所以，我，Jorua又回来啦！","categories":[{"name":"随便聊聊","slug":"随便聊聊","permalink":"http://joruachan.cn/categories/%E9%9A%8F%E4%BE%BF%E8%81%8A%E8%81%8A/"}],"tags":[{"name":"除了工作以外的","slug":"除了工作以外的","permalink":"http://joruachan.cn/tags/%E9%99%A4%E4%BA%86%E5%B7%A5%E4%BD%9C%E4%BB%A5%E5%A4%96%E7%9A%84/"}],"author":"Jorua"},{"title":"史上最全synchronized关键字总结","slug":"synchronized-summary","date":"2021-03-21T16:00:00.000Z","updated":"2021-09-13T15:49:20.317Z","comments":true,"path":"2021-03-22/synchronized-summary/","link":"","permalink":"http://joruachan.cn/2021-03-22/synchronized-summary/","excerpt":"","text":"文章思路我在阅读文章时，更希望文章有个提纲或者思路，在阅读前可以理解他的思路，这样能快速明白他想说什么，将要怎么说。 本篇文章编写的思路： 回顾下理论知识：信号量。因为信号量是解决并发过程中互斥和同步问题的最基础的模型; 介绍管程模型，管程模型是针对信号量的一个改进模型; 再介绍Java中是如何实现和使用管程模型的; 最后介绍下Java对synchronized重量级锁的优化; 信号量你的脑袋里，是不是还能蹦出共享资源、临界区、P方法、V方法等等字眼词汇？那说明你的课本知识还是很扎实的！ 信号量机制是由荷兰学者Dijkstra提出的进程同步工具，它被大量使用在处理机系统和计算机网络中！其中，包含了两个重要属性和两个重要的方法。 PS：我这里介绍的内容，为了更好的理解经过了一定的加工，不完全和理论介绍一致！ 两个重要属性 count，共享资源数量，count &gt; 0表示还存在共享资源可以获取，count &lt; 0则表示共享资源已经获取完了，只能等资源被释放； 等待队列，当count &lt; 0时，线程需阻塞直到资源释放，这些线程需要加入到等待队列中； 两个重要方法 P：获取资源，即对count-1，如果结果&gt;=0，则获取资源成功；但是结果&lt;0的话，线程则加入到等待队列并进入阻塞状态； V：释放资源，即对count+1，如果结果&gt;0，则不做特殊操作；但是结果&lt;=0，则表示有线程需要共享资源，则从等待队列中唤醒一个线程恢复执行； 使用方法 只有P和V方法能操作count属性； P和V方法必须成对出现，否则对共享资源的控制不准确； P方法可能阻塞，但是不能无限期阻塞； 问题 易造成死锁 如果一段逻辑中存在多个信号量间的交互，有着很经典的问题：比如A和B间，A依赖着B，B又依赖着A，如果控制不合理，很容易造成死锁； 饥饿现象 调度器的不公平，会造成线程等待时间较长产生饥饿现象； 对程序员不友好 如果依靠信号量间来完成多个临界区的同步或者互斥，那么会有大量的P/V方法，难以维护； 管程管程模型是在信号量的基础上改进的模型，很大程度上解决了上述信号量存在的问题，并且隐藏了很多同步细节。 改进点· 吞吐量提高 管程模型允许多个进（线）程先进入模型，再根据同步条件来判断是否能进入临界区；而信号量模型同一个信号量不论何种情况，都只能一个进（线）程进入； · 条件队列（条件同步） 管程模型在信号量模型的基础上，添加了条件同步概念。通过使用条件队列，已经获得共享资源的进（线）程可以释放共享资源，并将进（线）程添加到条件队列中阻塞，一直等到某个条件成立，使得该进（线）程回到等待队列重新获取共享资源，再继续执行后续逻辑；具体的代码实现可以参考j.u.c中的Condition接口和具体实现； 管程和信号量的比较，图片来自于网络 深入理解在信号量的模型中，一个共享变量需要一个信号量模型支持；如果存在多个共享变量，就需要多个信号量来支持。 举例说明：两个共享资源A和B以及对应的信号量Sa和Sb；一个线程Ta利用Sa信号量的P方法获取到共享资源A，然后尝试获取共享资源B（未执行V方法）；另一个线程Tb在Ta获取到A的同时也获取到B，然后Tb又需要获取A。则最后的现象就是Ta需要等待Tb释放B，Tb在等Ta释放A，谁也不放过谁，而造成了死锁；具体可以参照伪代码理解： 信号量死锁伪代码1234567891011121314151617181920212223Sa&#123; int A; P()&#123; // 阻塞直到满足条件 if(--A &gt;= 0) &#123; ... Sb.P() ... &#125; &#125;&#125;Sb&#123; int B; P()&#123; // 阻塞直到满足条件 if(--B &gt;= 0) &#123; ... Sa.P() ... &#125; &#125;&#125; 管程则针对上述问题，提出一个更方便、更易理解的模型。从线程的角度去管理和协调共享资源，拥有管程的线程可以放弃使用权，并等待恢复。 从而解决上述列出的伪代码的问题了！ 管程伪代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Sa&#123; int A; P()&#123; while(true)&#123; if(获取共享资源A成功)&#123; ... while(true)&#123; if (获取共享资源B成功) &#123; ... // 唤起等待资源B的线程 Sb.notify() break; &#125; else &#123; // 释放共享资源A的控制权 Sa.wait() &#125; &#125; ... Sa.notify() break; &#125; &#125; &#125; wait()&#123; // 释放A的控制权 &#125; notify()&#123; // 唤起等待A的线程 &#125;&#125;Sb&#123; int B; P()&#123; while(true)&#123; if(获取共享资源B成功)&#123; ... while(true)&#123; if (获取共享资源A成功) &#123; ... // 唤起等待资源A的线程 Sa.notify() break; &#125; else &#123; // 释放共享资源B的控制权 Sb.wait() &#125; &#125; ... Sb.notify() break; &#125; &#125; &#125; wait()&#123; // 释放B的控制权 &#125; notify()&#123; // 唤起等待B的线程 &#125;&#125; 如上，通过wait和notify两个方法，可以很好地解决多个共享变量间的协调问题； MESA模型管程的具体实现，当前最流行的就是MESA模型。它有个基本的编程范式：在一个while循环里面调用wait()，增加一个超时参数防止饥饿； 除了MESA模型，还有Hoare模型和Brinch Hanson 模型，感兴趣的同学可以了解下。 synchronized底层原理字节码表现我们先来举个例子： SynchronizedTest.java123456789101112131415161718192021public class SynchronizedTest &#123; int count = 0; // 普通方法 public void normalMethod() &#123; count++; &#125; // 同步方法，只能锁住当前实例的对象 public synchronized void syncMethod() &#123; count++; &#125; // 同步代码块，这里可以指定同步资源 public void syncCodeBlock() &#123; synchronized(this) &#123; count++; &#125; &#125;&#125; 这段代码很简单，一个普通的方法，一个同步方法，还有一个同步代码块。我们先通过javac编译成.class文件，再用javap查看其汇编指令，具体观察下如何运作的。 汇编指令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960Compiled from &quot;SynchronizedTest.java&quot;public class SynchronizedTest &#123;int count;public SynchronizedTest();Code:0: aload_01: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V4: aload_05: iconst_06: putfield #2 // Field count:I9: returnpublic void normalMethod();Code:0: aload_01: dup2: getfield #2 // Field count:I5: iconst_16: iadd7: putfield #2 // Field count:I10: returnpublic synchronized void syncMethod();Code:0: aload_01: dup2: getfield #2 // Field count:I5: iconst_16: iadd7: putfield #2 // Field count:I10: returnpublic void syncCodeBlock();Code:0: aload_01: dup2: astore_13: monitorenter4: aload_05: dup6: getfield #2 // Field count:I9: iconst_110: iadd11: putfield #2 // Field count:I14: aload_115: monitorexit16: goto 2419: astore_220: aload_121: monitorexit22: aload_223: athrow24: returnException table:from to target type4 16 19 any19 22 19 any&#125; 主要关注第24～32行和第34～54行；可以很快的发现，同步方法其实和普通方法在字节码角度去看是没有任何区别的；但是，同步方法块中，是通过显式的monitorenter和monitorexit，JVM在执行时候便会进行同步处理，具体如何操作我们稍作讲解； 同步方法到底是怎么操作的呢？其实，了解过Class文件的同学应该知道Class文件中有方法表，方法表定义了每个方法信息method_info，该结构体中有个access_flags字段记录方法的访问标记，其中synchronized就会被记录。当方法被调用的时候发现access_flags定义了synchronized标记，如果是静态方法则针对该Class对象进行同步处理，如果是实例方法则针对实例对象进行同步处理； ObjectMonitor——管程在JVM中的实现上一小节中说到了，JVM如何知道程序员定义的方法或者代码块需要同步处理；那么说到JVM同步处理，就必须要知道ObjectMonitor结构体了。 管程在JVM中的具体实现是ObjectMonitor，可以参考HotSpot源码：ObjectMonitor.hpp；主要的属性包含： _entryList：希望进入管程monitor对象，处于blocked状态的线程； _waitSet：已经获得过锁，但是在条件队列上处于wait状态的线程； ObjectMonitor图解，图片源于百度搜索结果 当线程处理到同步逻辑时候，会进入同步对象的ObjectMonitor中。线程会enter放置到EntrySet集合中。当线程acquire到资源后，就进入临界区中；如果需要条件等待，则release锁并放置到WaitSet集合中等待再次被唤醒，重新acquire进入临界区；如果逻辑处理完成，便会release锁，并退出临界区。 Mutex LockObjectMonitor只是高级语言写出的结构体，在转换成010101二进制码给CPU处理时，硬件是如何保证线程间的互斥性呢？ 我们先引出操作系统中的Mutex Lock。这个锁是具有排他性的，所有线程中只会有一个线程才能获取到；没有获取到锁的线程可能会进入睡眠，这样就会存在线程上下文切换的小号。ObjectMonitor就是基于此实现的。操作系统的MutexLock是怎么实现的，笔者也不是特别清楚，就不随意发言了。有兴趣的同学可以研究下，顺便留言和大家分享下呢！或者如果有高手的话，还请多多指教！ 从硬件的角度看互斥性的实现，就是需要保证多个CPU核之间的执行唯一性。MESI协议、总线锁，都是实现互斥的关键技术。 synchronized锁优化上面介绍了管程的概念以及实现，相信大家都有了一定的认知了。但是！我这边提出一个场景： 只有少量的线程抢占共享资源 因为上面说到是由MutexLock实现的，不论多少个线程，哪怕只有一个线程在抢占时，也是需要锁住CPU核，从而造成资源浪费；所以MutexLock称之为重量级锁。Java 1.6后引入了偏向锁和轻量级锁，线程在较少的抢占情况下，无需通过MutexLock来获取锁； 对象头一个Java对象在JVM中，分成三个区域：对象头、实例数据、对齐填充； 实例数据：4个字节对齐，存储类的数据，包括父类属性，如果是数组还包括数据长度； 对象头：一部分存储自身运行时数据，如GC年代、哈希码、锁信息等，在32/64位机器占用32/64位，官方称为Mark Word；另一部分则存储对象类型数据的指针，数组对象还需存储数组的长度； 填充数据：JVM要求对象起始地址必须是8字节的倍数，仅为了对齐； JVM为了空间效率，Mark Word设计成非固定数据结构，以便存储更多数据；具体如下: MarkWord不同形式，图片源于网络 锁的升级和撤销上面其实已经说过，synchronized在未优化前，不论何种场景都是按照重量级锁进行互斥的；Java1.6后，JVM会根据不同的场景做了优化以及升级； 上小节的图片中可以看到MarkWord会存在四种状态：无锁、偏向锁、轻量级锁以及重量级锁，按照这个顺序不断升级锁来适应不同的场景。注：synchronized不能降级！ 无锁升级成偏向锁如果当前只有一个线程运行，此时只会加上偏向锁。具体过程是: 线程会先查看MarkWord的锁标记位和偏向锁标记位，如果是无锁状态，则当前线程可获得偏向锁； 通过CAS无锁的方式将MarkWord的偏向锁标记位修改为1，以及赋值当前线程ID； 偏向锁撤销，升级成轻量级锁如上，已经有一个线程A获得了偏向锁，此时又有一个线程B来获取锁： 线程B会先查看MarkWord的锁标记位和偏向锁标记位，发现是偏向锁状态； 判断偏向锁线程id是否为自己，如果是则已经获取；如果不是自己，则尝试通过CAS设置MarkWord，则需要发起撤销偏向锁； 暂停线程A，解偏向锁并将线程id置为空，再恢复线程B；（此阶段会STW, 撤销完后MarkWord此时无锁状态） 线程A和B会竞争轻量级锁，都会先在自己的线程栈上分配空间并复制对象头的MarkWord作为Displaced MarkWord，A、B通过CAS无锁方式将对象头的Markword指向自己栈空间； 只有一个线程能成功，该线程获得轻量级锁； 轻量级锁撤销，升级成重量级锁假设线程A获得轻量级锁，线程B未获取到； 线程B会继续CAS尝试将Markword指向自己的DisplacedMarkWord；当尝试到一定次数后仍失败，则将锁膨胀修改成重量级锁，阻塞住； 线程A会将对象头的MarkWord通过CAS修改恢复，释放锁，并唤醒线程B； 此时对象头的锁标记位就是10了，即重量级锁。A和B就需要进行介绍的重量级锁的竞争了；","categories":[],"tags":[{"name":"Java面试复习","slug":"Java面试复习","permalink":"http://joruachan.cn/tags/Java%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"},{"name":"多线程","slug":"多线程","permalink":"http://joruachan.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"author":"Jorua"},{"title":"MySQL统计信息研究","slug":"mysql-stats-info-explore","date":"2021-01-30T16:00:00.000Z","updated":"2021-02-01T16:00:00.000Z","comments":true,"path":"2021-01-31/mysql-stats-info-explore/","link":"","permalink":"http://joruachan.cn/2021-01-31/mysql-stats-info-explore/","excerpt":"","text":"阅读此文，最好事先了解MySQL对SQL语句的执行流程。笔者后续会针对性地补充相关内容，敬请期待！ 统计信息简介了解过SQL语句执行流程的童鞋应该都知道，查询优化器会根据统计信息和代价模型计算每个执行计划的成本大小，从而选择成本最小的执行计划；总而言之，统计信息是决定最终explain所见的执行计划的一个重要因素！ 统计信息分成非持久化统计信息和持久化统计信息；统计信息可由MySQL专门的后台线程dict_stats_thread自动触发更新，也可手动更新； 非持久化统计信息非持久化的统计信息是存在内存中的，数据库重启后会丢失；所以在重启时，大量表会更新统计信息，会对数据库实例造成较大影响； 开启方式：全局变量，针对全局表的默认设置，INNODB_STATS_PERSISTENT = OFF; 或者只针对某个表，在create或者alter时候设置STATS_PERSISTENT = 0; 自动更新 (主要) 场景： 1. 距离上次统计信息更新，表中1/16的数据被修改； 2. innodb_stats_on_metadata=ON的情况下，SHOW TABLE STATUS，SHOW INDEX以及查询INFORMATION_SCHEMA下的TABLES或STATISTICS； 上面说到，非持久化统计信息在数据库重启的时候会大量更新，对数据库造成影响，所以生产上几乎不会采用这种方案； 持久化统计信息持久化的统计信息是存在物理表中的，数据库重启后不会丢失；具体的表为：mysql库下的innodb_index_stats和innodb_table_stats； 开启方式：5.6.6版本后MySQL默认开启持久化统计信，即INNODB_STATS_PERSISTENT = ON； 自动更新（主要）场景： 1. 距离上次统计信息更新，表中1/10的数据被修改； 2. 新建索引，重建索引，truncate； innodb_table_stats表先看下innodb_table_stats表的DDL innodb_table_stats DDL123456789CREATE TABLE `innodb_table_stats` ( `database_name` varchar(64) COLLATE utf8_bin NOT NULL, `table_name` varchar(64) COLLATE utf8_bin NOT NULL, `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `n_rows` bigint(20) unsigned NOT NULL, `clustered_index_size` bigint(20) unsigned NOT NULL, `sum_of_other_index_sizes` bigint(20) unsigned NOT NULL, PRIMARY KEY (`database_name`,`table_name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin STATS_PERSISTENT=0 字段介绍 database_name: 数据库名称； table_name: 表名称； last_update: 更新时间； n_rows: 表数据的总行数； clustered_index_size: 聚簇索引的总页数； sum_of_other_index_sizes: 非聚簇索引的总页数； 引申介绍聚簇索引：innodb引擎，必须有且只有一个主键，这种索引是将数据和索引存储在一起的，只要找到索引的位置就可以找到行数据；但是通过辅助索引需要经历两次查询，先通过辅助索引找到主键位置，再通过聚簇索引找到数据； 非聚簇索引：myisam引擎，索引和数据是分开存储的，索引的叶子节点指向数据行地址；辅助索引和主键索引以及数据文件都是独立的；myisam通过key_buffer把索引先缓存到内存中，当通过索引访问数据时，在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因； innodb_index_stats表先看下innodb_index_stats表的DDL innodb_index_stats DDL1234567891011CREATE TABLE `innodb_index_stats` ( `database_name` varchar(64) COLLATE utf8_bin NOT NULL, `table_name` varchar(64) COLLATE utf8_bin NOT NULL, `index_name` varchar(64) COLLATE utf8_bin NOT NULL, `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `stat_name` varchar(64) COLLATE utf8_bin NOT NULL, `stat_value` bigint(20) unsigned NOT NULL, `sample_size` bigint(20) unsigned DEFAULT NULL, `stat_description` varchar(1024) COLLATE utf8_bin NOT NULL, PRIMARY KEY (`database_name`,`table_name`,`index_name`,`stat_name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin STATS_PERSISTENT=0 字段介绍 database_name: 数据库名称； table_name: 表名称； index_name: 索引名称； last_update: 更新时间； stat_name: 统计信息名； stat_value: 统计信息值； sample_size: 采样大小； stat_description: 类型说明； 统计项说明如果翻看innodb_index_stats表数据，你会发现每个索引都会有多个统计项(stat_name)；主要如下： stat_name统计项 stat_value含义 size 索引的页数量 n_leaf_pages 叶子节点的数量 n_diff_pfxNN 索引上唯一值的数量；因为索引可能是多列，所以NN表示从左递增的列组合唯一值的数量；注意如果是普通索引除去自身索引列的统计，还会加上唯一索引列进行统计； 了解stat_name和stat_value的具体含义，可以在解决或者优化慢查询问题上，起到一定的作用。如果统计值远小于实际值，查询优化器基本上不会选择该索引进行查询检索； n_diff_pfxNN举例说明假设表有字段：a、b、c、d、e，唯一索引：uix_a_b_c(a, b, c)， 普通索引：idx_d_e(d, e)；针对唯一索引uix_a_b_c则会有统计项： 1. n_diff_pfx01表示列a上的唯一值数量；2. n_diff_pfx02表示a,b两列组合的唯一值数量；3. n_diff_pfx03表示a,b,c三列组合的唯一值数量；针对普通索引：idx_d_e则会有统计项： 1. n_diff_pfx01表示d列上的唯一值数量；2. n_diff_pfx02表示d, e两列组合的唯一值数量；3. n_diff_pfx03表示d, e, a三列组合的唯一值数量；3. n_diff_pfx04表示d, e, a, b四列组合的唯一值数量；3. n_diff_pfx05表示d, e, a, b, c五列组合的唯一值数量； 手动更新统计信息执行ANALYZE TABLE table_name。注意：执行此语句时，需要保证用户拥有select和insert的权限；执行时，会持有innodb表的readonly锁，从而会短暂导致表的写入、更新、删除操作； 统计信息不准确，怎么办？如我的随笔中，《什么？MySQL还有统计信息一说？》一文中，有说到生产环境更新了索引，经过执行计划的查看，查询优化器并没有使用新建的索引； 运维查看了统计信息后，发现统计信息不准确，便执行ANALYZE TABLE table_name刷新了统计信息，便可以正常使用索引查询了。 所以，我们来整理下，如果发现索引没有正常被使用，发现和解决问题的大致思路。如有不适当的地方，欢迎大家留言点拨和斧正！ 第一步：检查索引是否建立起来，如果这步都漏了，是得好好反思下了； 第二步：索引正常建立，查询还是很慢，则查看执行计划，判断索引是否正常被使用；如果没被使用则走第三步，被使用了则走第四步； 第三步：索引正常建立，但是执行计划没有选择该索引；则查看统计信息，如果统计信息异常，则执行ANALYZE TABLE table_name刷新统计信息；还没有恢复，则调大采样变量大小； 第四步：索引正常建立，执行计划也选择了该索引，在SQL无问题的前提下需要考虑设计方面； 注： 以上步骤建立在SQL没有问题的情况之上！","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://joruachan.cn/tags/MySQL/"}],"author":"Jorua"},{"title":"什么？MySQL还有统计信息一说？","slug":"mysql-stats-info","date":"2021-01-29T16:00:00.000Z","updated":"2021-08-25T10:52:55.651Z","comments":true,"path":"2021-01-30/mysql-stats-info/","link":"","permalink":"http://joruachan.cn/2021-01-30/mysql-stats-info/","excerpt":"","text":"笔者最近在项目上对现有表进行了结构优化，并对一个常用表添加了索引。可谓测试环境玩漂移，生产环境怕翻车啊。上线验证的那一刻，突然发现一个类似报表功能的查询SQL极慢！ 背景说明 故障简查 检查添加索引索引的SQL，查看SQL执行结果，检查DDL。一顿操作后，表象上没看出问题 比较执行计划 连接sit环境执行explain，发现没问题，索引正常用上的。在生产的dbms上执行explain，发现索引没有用上，join查询时全表扫描了 查看MySQL版本 sit和prd环境都是5.7.22版本，看样子也不是版本不同造成的 再次分析 既然MySQL版本也一样，DDL也一样，为啥执行计划就是不一样呢？一边猜测着是不是有什么缓存，一边为了节约发布时间，让运维帮忙先把索引删掉再重新添加下 问题暴露 也许是运维对问题的普遍性或者敏感性，过了两三分钟，没对索引操作便通知我们好了！心里便纳了闷了，运维大牛确实牛啊！咨询了一番，便引出今天的话题了：刷新了统计信息 统计信息研究笔者学识浅薄，未曾了解“统计信息”。特此奉上，统计信息研究！大神勿喷！ 本文为随笔，具体的研究文章见： MySQL统计信息研究https://joruachan.cn/2021-01-31/mysql-stats-info-explore/","categories":[{"name":"随笔","slug":"随笔","permalink":"http://joruachan.cn/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://joruachan.cn/tags/MySQL/"}],"author":"Jorua"},{"title":"纪实:nodejs+hexo+volantis快速构建个人Blog","slug":"fast-build-blog","date":"2021-01-16T16:00:00.000Z","updated":"2021-08-25T10:52:55.651Z","comments":true,"path":"2021-01-17/fast-build-blog/","link":"","permalink":"http://joruachan.cn/2021-01-17/fast-build-blog/","excerpt":"","text":"即使身为一个钢铁直男的技术人，能拥有一个分享自己技术心得和生活分享的小窝，想必是每个技术人都考虑过的事情吧! 笔者这就告诉你一个秘密：只需执行几行命令，改点配置，一个端庄不失典雅的博客网站就能生成好！ 搭建环境简介nodejs + hexo; nodejs的安装本文不再介绍，不熟悉的同学可前往nodejs官网学习并安装；本站选用hexo的volantis主题介绍建站的， hexo提供了330款主题，如有需要，可前往查看其他主题 NodeJshttps://nodejs.org/en/ Hexohttps://hexo.io/ Volantishttps://volantis.js.org/ hexo简介hexo 自称为：快速、简洁且高效的博客框架。 笔者用起来确实还可以，大概介绍下几个特性： 提供了不同的layout，可将文章存为草稿，需要时publish即可； 可维护全局的数据，在source/_data文件夹下添加yaml文件，通过site.data获取； 可指定文件的特有变量，通过Front-matter实现； 支持模板，在scaffolds文件夹下可自定义模板，并进行发布； 支持标签插件，可以在文章文件中使用标签%%来插入特定内容； 提供命令行操作，如：hexo init初始化项目、hexo new新建文章、hexo pulish发布草稿文件、hexo generate生成静态文件、hexo server启动服务器； hexo搭建博客步骤 前提是必须安装好git和nodejs； 执行 “npm install -g hexo-cli”，安装好hexo； 选定文件夹，通过 “hexo init $folder” 初始化一个名为 $folder 的文件夹； cd $folder, 再执行npm install，至此hexo的博客框架已经搭建完成！ 完成上述步骤后，可执行hexo server, 访问http://localhost:4000, 会发现一个HelloWorld页面已经可以访问！ 选用volantis主题 设置项目使用的主题: 项目根目录下的_config.yml文件中设置 theme: volantis; 如果Hexo版本在5.0.2及以上，可以直接通过npm i hexo-theme-volantis进行安装；笔者为了项目的可读性，采用了源代码拷贝到theme文件夹的方案（记得删除.git文件夹,否则git提交时会出问题!） 按照依赖的插件：npm i hexo-generator-search hexo-generator-json-content(站内搜索)，npm i hexo-renderer-stylus（Stylus 渲染器） 完成上述步骤后执行hexo server, 访问http://localhost:4000, 是不是发现端庄不失典雅的博客网站已经完成了！ 尝试新建文章执行 hexo new post $newPostName，会在_post文件夹下新建一个名为$newPostName的md文件，一个新的文章便建立完成。 这时你只需要关注你的博文输出即可啦！ 发布至GitHub Pages如果你期望能通过GitHub Pages来访问你的博客网站，做如下几步： 通过GitHub新建一个repository，名为：&lt;你的 GitHub 用户名&gt;.github.io； 本地检出该repository； 在博客源码的项目中执行命令：hexo generate –deploy，会生成public文件夹，该文件夹里便是博客所有的静态页面文件； 将public文件夹中的文件全部拷贝到新建repository的master分支下； 将master文件推送至远程master分支即可！ 静待一会，访问：http://&lt;你的 GitHub 用户名&gt;.github.io便能访问你自定义的博客了！ 如果你有自己的域名，可以在域名解析配置成 记录类型：CNAME，记录值：&lt;你的 GitHub 用户名&gt;.github.io。 注意了！！！ 此时还需要在GitHub Page项目中根目录下加上名为CNAME的文件，文件内容为你自己的域名。 正如你看到的，搭建一个个人博客网站就是如此便捷！ 如果你喜欢的话，点个赞，分享分享下吧！谢谢~","categories":[],"tags":[],"author":"Jorua"}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://joruachan.cn/categories/%E9%9A%8F%E7%AC%94/"},{"name":"随便聊聊","slug":"随便聊聊","permalink":"http://joruachan.cn/categories/%E9%9A%8F%E4%BE%BF%E8%81%8A%E8%81%8A/"}],"tags":[{"name":"除了工作以外的","slug":"除了工作以外的","permalink":"http://joruachan.cn/tags/%E9%99%A4%E4%BA%86%E5%B7%A5%E4%BD%9C%E4%BB%A5%E5%A4%96%E7%9A%84/"},{"name":"《见识》","slug":"《见识》","permalink":"http://joruachan.cn/tags/%E3%80%8A%E8%A7%81%E8%AF%86%E3%80%8B/"},{"name":"Netty","slug":"Netty","permalink":"http://joruachan.cn/tags/Netty/"},{"name":"Java面试复习","slug":"Java面试复习","permalink":"http://joruachan.cn/tags/Java%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"},{"name":"高并发","slug":"高并发","permalink":"http://joruachan.cn/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://joruachan.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"抓包","slug":"抓包","permalink":"http://joruachan.cn/tags/%E6%8A%93%E5%8C%85/"},{"name":"RTP","slug":"RTP","permalink":"http://joruachan.cn/tags/RTP/"},{"name":"网络协议","slug":"网络协议","permalink":"http://joruachan.cn/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"JDK","slug":"JDK","permalink":"http://joruachan.cn/tags/JDK/"},{"name":"基础知识","slug":"基础知识","permalink":"http://joruachan.cn/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"框架","slug":"框架","permalink":"http://joruachan.cn/tags/%E6%A1%86%E6%9E%B6/"},{"name":"数据结构","slug":"数据结构","permalink":"http://joruachan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"多线程","slug":"多线程","permalink":"http://joruachan.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"MySQL","slug":"MySQL","permalink":"http://joruachan.cn/tags/MySQL/"}]}