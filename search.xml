<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>这是我的一半2021</title>
      <link href="/2021-09-07/half-of-2021/"/>
      <url>/2021-09-07/half-of-2021/</url>
      
        <content type="html"><![CDATA[<p>这篇文章起笔时间，2021年9月7日晚上。 </p><p>间隔上篇博文，又过去了5个多月。中间发生了很多事，似乎明白了很多，让我坚定了很多选择；但是似乎又增添了不少疑惑，疑惑那些打破我认知的事情。不要觉得我矫情，也许你们觉得很正常，于我来说，可能正在经历生活、职场等等方面的历练。</p><p>简单说下吧。</p><ul><li>婚姻，我们在三年恋爱后，终于————我迎娶她成为了丈夫，她嫁给我成为了妻子；感谢有她，庆幸有她！</li><li>新房，房子在婚姻上我认为是个必需品，媳妇和我花了不少时间、心思在装配上，完美收官让我们心满意足；愿家愈来愈好！</li><li>离职，陪上家公司经历了一段最困难的时期，不舍归不舍，生活还是要继续；祝福它吧！</li><li>新城市，朝钱看所以我换了城市，上午仍在家，下午奔至另一个城市，快节奏让我觉得哪哪都是陌生的；但愿新城市温柔点！</li><li>新工作，在我第四年的工作经验情况下，让我时时自己问自己：原来你不知道的还是有这么多？当然更多的原因是没有接触过的业务；卷起来吧！</li></ul><p>2021不一般！带着憧憬，带着责任，全力以赴。<br>当然现在，所有的一切都逐渐稳定了。所以，我，Jorua又回来啦！</p>]]></content>
      
      
      <categories>
          
          <category> 随便聊聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 除了工作以外的 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>史上最全synchronized关键字总结</title>
      <link href="/2021-03-22/synchronized-summary/"/>
      <url>/2021-03-22/synchronized-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="文章思路"><a href="#文章思路" class="headerlink" title="文章思路"></a>文章思路</h2><p>我在阅读文章时，更希望文章有个提纲或者思路，在阅读前可以理解他的思路，这样能快速明白他想说什么，将要怎么说。</p><p>本篇文章编写的思路：</p><ol><li>回顾下理论知识：信号量。因为信号量是解决并发过程中互斥和同步问题的最基础的模型;</li><li>介绍管程模型，管程模型是针对信号量的一个改进模型;</li><li>再介绍Java中是如何实现和使用管程模型的;</li><li>最后介绍下Java对synchronized重量级锁的优化;</li></ol><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>你的脑袋里，是不是还能蹦出共享资源、临界区、P方法、V方法等等字眼词汇？那说明你的课本知识还是很扎实的！</p><p>信号量机制是由荷兰学者Dijkstra提出的进程同步工具，它被大量使用在处理机系统和计算机网络中！其中，包含了两个重要属性和两个重要的方法。</p><p>PS：我这里介绍的内容，为了更好的理解经过了一定的加工，不完全和理论介绍一致！</p><h3 id="两个重要属性"><a href="#两个重要属性" class="headerlink" title="两个重要属性"></a>两个重要属性</h3><ol><li>count，共享资源数量，count &gt; 0表示还存在共享资源可以获取，count &lt; 0则表示共享资源已经获取完了，只能等资源被释放；</li><li>等待队列，当count &lt; 0时，线程需阻塞直到资源释放，这些线程需要加入到等待队列中；</li></ol><h3 id="两个重要方法"><a href="#两个重要方法" class="headerlink" title="两个重要方法"></a>两个重要方法</h3><ol><li>P：获取资源，即对count-1，如果结果&gt;=0，则获取资源成功；但是结果&lt;0的话，线程则加入到等待队列并进入阻塞状态；</li><li>V：释放资源，即对count+1，如果结果&gt;0，则不做特殊操作；但是结果&lt;=0，则表示有线程需要共享资源，则从等待队列中唤醒一个线程恢复执行；</li></ol><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>只有P和V方法能操作count属性；</li><li>P和V方法必须成对出现，否则对共享资源的控制不准确；</li><li>P方法可能阻塞，但是不能无限期阻塞；</li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>易造成死锁</p><p>  如果一段逻辑中存在多个信号量间的交互，有着很经典的问题：比如A和B间，A依赖着B，B又依赖着A，如果控制不合理，很容易造成死锁；</p></li><li><p>饥饿现象</p><p>  调度器的不公平，会造成线程等待时间较长产生饥饿现象；</p></li><li><p>对程序员不友好</p><p>  如果依靠信号量间来完成多个临界区的同步或者互斥，那么会有大量的P/V方法，难以维护；</p></li></ul><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>管程模型是在信号量的基础上改进的模型，很大程度上解决了上述信号量存在的问题，并且隐藏了很多同步细节。</p><h3 id="改进点"><a href="#改进点" class="headerlink" title="改进点"></a>改进点</h3><p><strong>· 吞吐量提高</strong></p><p>管程模型允许多个进（线）程先进入模型，再根据同步条件来判断是否能进入临界区；而信号量模型同一个信号量不论何种情况，都只能一个进（线）程进入；</p><p><strong>· 条件队列（条件同步）</strong></p><p>管程模型在信号量模型的基础上，添加了条件同步概念。通过使用条件队列，已经获得共享资源的进（线）程可以释放共享资源，并将进（线）程添加到条件队列中阻塞，一直等到某个条件成立，使得该进（线）程回到等待队列重新获取共享资源，再继续执行后续逻辑；具体的代码实现可以参考j.u.c中的Condition接口和具体实现；</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/synchronized-summary/compare-mointor-semaphere.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/synchronized-summary/compare-mointor-semaphere.png" srcset="data:image/png;base64,666" alt="管程和信号量的比较，图片来自于网络"/></div><span class="image-caption">管程和信号量的比较，图片来自于网络</span></div><h3 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h3><p>在信号量的模型中，一个共享变量需要一个信号量模型支持；如果存在多个共享变量，就需要多个信号量来支持。</p><p>举例说明：两个共享资源A和B以及对应的信号量Sa和Sb；一个线程Ta利用Sa信号量的P方法获取到共享资源A，然后尝试获取共享资源B（未执行V方法）；另一个线程Tb在Ta获取到A的同时也获取到B，然后Tb又需要获取A。则最后的现象就是Ta需要等待Tb释放B，Tb在等Ta释放A，谁也不放过谁，而造成了死锁；具体可以参照伪代码理解：</p><figure class="highlight plaintext"><figcaption><span>信号量死锁伪代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Sa&#123;</span><br><span class="line">    int A;</span><br><span class="line">    P()&#123;</span><br><span class="line">        // 阻塞直到满足条件</span><br><span class="line">        if(--A &gt;= 0) &#123;</span><br><span class="line">            ... </span><br><span class="line">            Sb.P()</span><br><span class="line">            ... </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sb&#123;</span><br><span class="line">    int B;</span><br><span class="line">    P()&#123;</span><br><span class="line">        // 阻塞直到满足条件</span><br><span class="line">        if(--B &gt;= 0) &#123;</span><br><span class="line">            ...</span><br><span class="line">            Sa.P()</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管程则针对上述问题，提出一个更方便、更易理解的模型。<wavy>从线程的角度去管理和协调共享资源，拥有管程的线程可以放弃使用权，并等待恢复。</wavy> 从而解决上述列出的伪代码的问题了！</p><figure class="highlight plaintext"><figcaption><span>管程伪代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">Sa&#123;</span><br><span class="line">    int A;</span><br><span class="line">    P()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(获取共享资源A成功)&#123;</span><br><span class="line">                ... </span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    if (获取共享资源B成功) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                        // 唤起等待资源B的线程</span><br><span class="line">                        Sb.notify()</span><br><span class="line"></span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 释放共享资源A的控制权</span><br><span class="line">                        Sa.wait()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                Sa.notify()    </span><br><span class="line">                break; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait()&#123; // 释放A的控制权 &#125;</span><br><span class="line"></span><br><span class="line">    notify()&#123; // 唤起等待A的线程 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sb&#123;</span><br><span class="line">    int B;</span><br><span class="line">    P()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(获取共享资源B成功)&#123;</span><br><span class="line">                ... </span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    if (获取共享资源A成功) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                        // 唤起等待资源A的线程</span><br><span class="line">                        Sa.notify()</span><br><span class="line"></span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 释放共享资源B的控制权</span><br><span class="line">                        Sb.wait()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                Sb.notify()    </span><br><span class="line">                break; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait()&#123; // 释放B的控制权 &#125;</span><br><span class="line"></span><br><span class="line">    notify()&#123; // 唤起等待B的线程 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，通过wait和notify两个方法，可以很好地解决多个共享变量间的协调问题；</p><h3 id="MESA模型"><a href="#MESA模型" class="headerlink" title="MESA模型"></a>MESA模型</h3><p>管程的具体实现，当前最流行的就是MESA模型。它有个基本的编程范式：在一个while循环里面调用wait()，增加一个超时参数防止饥饿；</p><p>除了MESA模型，还有Hoare模型和Brinch Hanson 模型，感兴趣的同学可以了解下。</p><h2 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h2><h3 id="字节码表现"><a href="#字节码表现" class="headerlink" title="字节码表现"></a>字节码表现</h3><p>我们先来举个例子：</p><figure class="highlight plaintext"><figcaption><span>SynchronizedTest.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedTest &#123;</span><br><span class="line">int count = 0;</span><br><span class="line"></span><br><span class="line">// 普通方法</span><br><span class="line">public void normalMethod() &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同步方法，只能锁住当前实例的对象</span><br><span class="line">public synchronized void syncMethod() &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 同步代码块，这里可以指定同步资源</span><br><span class="line">public void syncCodeBlock() &#123;</span><br><span class="line">synchronized(this) &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，一个普通的方法，一个同步方法，还有一个同步代码块。我们先通过javac编译成.class文件，再用javap查看其汇编指令，具体观察下如何运作的。</p><figure class="highlight plaintext"><figcaption><span>汇编指令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;SynchronizedTest.java&quot;</span><br><span class="line">public class SynchronizedTest &#123;</span><br><span class="line">int count;</span><br><span class="line"></span><br><span class="line">public SynchronizedTest();</span><br><span class="line">Code:</span><br><span class="line">0: aload_0</span><br><span class="line">1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">4: aload_0</span><br><span class="line">5: iconst_0</span><br><span class="line">6: putfield      #2                  // Field count:I</span><br><span class="line">9: return</span><br><span class="line"></span><br><span class="line">public void normalMethod();</span><br><span class="line">Code:</span><br><span class="line">0: aload_0</span><br><span class="line">1: dup</span><br><span class="line">2: getfield      #2                  // Field count:I</span><br><span class="line">5: iconst_1</span><br><span class="line">6: iadd</span><br><span class="line">7: putfield      #2                  // Field count:I</span><br><span class="line">10: return</span><br><span class="line"></span><br><span class="line">public synchronized void syncMethod();</span><br><span class="line">Code:</span><br><span class="line">0: aload_0</span><br><span class="line">1: dup</span><br><span class="line">2: getfield      #2                  // Field count:I</span><br><span class="line">5: iconst_1</span><br><span class="line">6: iadd</span><br><span class="line">7: putfield      #2                  // Field count:I</span><br><span class="line">10: return</span><br><span class="line"></span><br><span class="line">public void syncCodeBlock();</span><br><span class="line">Code:</span><br><span class="line">0: aload_0</span><br><span class="line">1: dup</span><br><span class="line">2: astore_1</span><br><span class="line">3: monitorenter</span><br><span class="line">4: aload_0</span><br><span class="line">5: dup</span><br><span class="line">6: getfield      #2                  // Field count:I</span><br><span class="line">9: iconst_1</span><br><span class="line">10: iadd</span><br><span class="line">11: putfield      #2                  // Field count:I</span><br><span class="line">14: aload_1</span><br><span class="line">15: monitorexit</span><br><span class="line">16: goto          24</span><br><span class="line">19: astore_2</span><br><span class="line">20: aload_1</span><br><span class="line">21: monitorexit</span><br><span class="line">22: aload_2</span><br><span class="line">23: athrow</span><br><span class="line">24: return</span><br><span class="line">Exception table:</span><br><span class="line">from    to  target type</span><br><span class="line">4    16    19   any</span><br><span class="line">19    22    19   any</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要关注第24～32行和第34～54行；可以很快的发现，同步方法其实和普通方法在字节码角度去看是没有任何区别的；<br>但是，同步方法块中，是通过显式的monitorenter和monitorexit，JVM在执行时候便会进行同步处理，具体如何操作我们稍作讲解；</p><p>同步方法到底是怎么操作的呢？其实，了解过Class文件的同学应该知道Class文件中有方法表，方法表定义了每个方法信息method_info，该结构体中有个access_flags字段记录方法的访问标记，其中synchronized就会被记录。<br>当方法被调用的时候发现access_flags定义了synchronized标记，如果是静态方法则针对该Class对象进行同步处理，如果是实例方法则针对实例对象进行同步处理；</p><h3 id="ObjectMonitor——管程在JVM中的实现"><a href="#ObjectMonitor——管程在JVM中的实现" class="headerlink" title="ObjectMonitor——管程在JVM中的实现"></a>ObjectMonitor——管程在JVM中的实现</h3><p>上一小节中说到了，JVM如何知道程序员定义的方法或者代码块需要同步处理；那么说到JVM同步处理，就必须要知道ObjectMonitor结构体了。</p><p>管程在JVM中的具体实现是ObjectMonitor，可以参考HotSpot源码：ObjectMonitor.hpp；主要的属性包含：</p><ol><li>_entryList：希望进入管程monitor对象，处于blocked状态的线程；</li><li>_waitSet：已经获得过锁，但是在条件队列上处于wait状态的线程；</li></ol><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/synchronized-summary/object-monitor.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/synchronized-summary/object-monitor.png" srcset="data:image/png;base64,666" alt="ObjectMonitor图解，图片源于百度搜索结果"/></div><span class="image-caption">ObjectMonitor图解，图片源于百度搜索结果</span></div><p>当线程处理到同步逻辑时候，会进入同步对象的ObjectMonitor中。线程会<strong>enter</strong>放置到EntrySet集合中。当线程<strong>acquire</strong>到资源后，就进入临界区中；如果需要条件等待，则<strong>release</strong>锁并放置到WaitSet集合中等待再次被唤醒，重新<strong>acquire</strong>进入临界区；如果逻辑处理完成，便会<strong>release</strong>锁，并退出临界区。</p><h3 id="Mutex-Lock"><a href="#Mutex-Lock" class="headerlink" title="Mutex Lock"></a>Mutex Lock</h3><p>ObjectMonitor只是高级语言写出的结构体，在转换成010101二进制码给CPU处理时，硬件是如何保证线程间的互斥性呢？</p><p>我们先引出操作系统中的Mutex Lock。这个锁是具有排他性的，所有线程中只会有一个线程才能获取到；没有获取到锁的线程可能会进入睡眠，这样就会存在线程上下文切换的小号。ObjectMonitor就是基于此实现的。操作系统的MutexLock是怎么实现的，笔者也不是特别清楚，就不随意发言了。有兴趣的同学可以研究下，顺便留言和大家分享下呢！或者如果有高手的话，还请多多指教！</p><p>从硬件的角度看互斥性的实现，就是需要保证多个CPU核之间的执行唯一性。MESI协议、总线锁，都是实现互斥的关键技术。</p><h2 id="synchronized锁优化"><a href="#synchronized锁优化" class="headerlink" title="synchronized锁优化"></a>synchronized锁优化</h2><p>上面介绍了管程的概念以及实现，相信大家都有了一定的认知了。但是！我这边提出一个场景：</p><ul><li>只有少量的线程抢占共享资源</li></ul><p>因为上面说到是由MutexLock实现的，不论多少个线程，哪怕只有一个线程在抢占时，也是需要锁住CPU核，从而造成资源浪费；所以MutexLock称之为重量级锁。Java 1.6后引入了偏向锁和轻量级锁，线程在较少的抢占情况下，无需通过MutexLock来获取锁；</p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><h3 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h3><h3 id="锁的升级和撤销"><a href="#锁的升级和撤销" class="headerlink" title="锁的升级和撤销"></a>锁的升级和撤销</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Java面试复习 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL统计信息研究</title>
      <link href="/2021-01-31/mysql-stats-info-explore/"/>
      <url>/2021-01-31/mysql-stats-info-explore/</url>
      
        <content type="html"><![CDATA[<blockquote><p>阅读此文，最好事先了解MySQL对SQL语句的执行流程。<br>笔者后续会针对性地补充相关内容，敬请期待！</p></blockquote><h2 id="统计信息简介"><a href="#统计信息简介" class="headerlink" title="统计信息简介"></a>统计信息简介</h2><p>了解过SQL语句执行流程的童鞋应该都知道，查询优化器会根据统计信息和代价模型计算每个执行计划的成本大小，从而选择成本最小的执行计划；总而言之，统计信息是决定最终explain所见的执行计划的一个重要因素！</p><p>统计信息分成非持久化统计信息和持久化统计信息；统计信息可由MySQL专门的后台线程dict_stats_thread自动触发更新，也可手动更新；</p><h3 id="非持久化统计信息"><a href="#非持久化统计信息" class="headerlink" title="非持久化统计信息"></a>非持久化统计信息</h3><p>非持久化的统计信息是存在内存中的，数据库重启后会丢失；所以在重启时，大量表会更新统计信息，会对数据库实例造成较大影响；</p><p>开启方式：全局变量，针对全局表的默认设置，INNODB_STATS_PERSISTENT = OFF; 或者只针对某个表，在create或者alter时候设置STATS_PERSISTENT = 0;</p><p>自动更新 (主要) 场景：<br>    1. 距离上次统计信息更新，表中1/16的数据被修改；<br>    2. innodb_stats_on_metadata=ON的情况下，SHOW TABLE STATUS，SHOW INDEX以及查询INFORMATION_SCHEMA下的TABLES或STATISTICS；</p><p>上面说到，非持久化统计信息在数据库重启的时候会大量更新，对数据库造成影响，所以生产上几乎不会采用这种方案；</p><h3 id="持久化统计信息"><a href="#持久化统计信息" class="headerlink" title="持久化统计信息"></a>持久化统计信息</h3><p>持久化的统计信息是存在物理表中的，数据库重启后不会丢失；具体的表为：mysql库下的innodb_index_stats和innodb_table_stats；</p><p>开启方式：5.6.6版本后MySQL默认开启持久化统计信，即INNODB_STATS_PERSISTENT = ON；</p><p>自动更新（主要）场景：<br>    1. 距离上次统计信息更新，表中1/10的数据被修改；<br>    2. 新建索引，重建索引，truncate；</p><h2 id="innodb-table-stats表"><a href="#innodb-table-stats表" class="headerlink" title="innodb_table_stats表"></a>innodb_table_stats表</h2><p>先看下innodb_table_stats表的DDL</p><figure class="highlight sql"><figcaption><span>innodb_table_stats DDL</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `innodb_table_stats` (</span><br><span class="line">  `database_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `table_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `last_update` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `n_rows` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `clustered_index_size` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `sum_of_other_index_sizes` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`database_name`,`table_name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin STATS_PERSISTENT<span class="operator">=</span><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="字段介绍"><a href="#字段介绍" class="headerlink" title="字段介绍"></a>字段介绍</h3><ul><li>database_name: 数据库名称；</li><li>table_name: 表名称；</li><li>last_update: 更新时间；</li><li>n_rows: 表数据的总行数；</li><li>clustered_index_size: 聚簇索引的总页数；</li><li>sum_of_other_index_sizes: 非聚簇索引的总页数；</li></ul><figure class="highlight md"><figcaption><span>引申介绍</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">聚簇索引：innodb引擎，必须有且只有一个主键，这种索引是将数据和索引存储在一起的，只要找到索引的位置就可以找到行数据；</span><br><span class="line">但是通过辅助索引需要经历两次查询，先通过辅助索引找到主键位置，再通过聚簇索引找到数据； </span><br><span class="line"> </span><br><span class="line">非聚簇索引：myisam引擎，索引和数据是分开存储的，索引的叶子节点指向数据行地址；辅助索引和主键索引以及数据文件都是独立的；</span><br><span class="line">myisam通过key<span class="emphasis">_buffer把索引先缓存到内存中，当通过索引访问数据时，在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因；</span></span><br><span class="line"><span class="emphasis"></span></span><br></pre></td></tr></table></figure><h2 id="innodb-index-stats表"><a href="#innodb-index-stats表" class="headerlink" title="innodb_index_stats表"></a>innodb_index_stats表</h2><p>先看下innodb_index_stats表的DDL</p><figure class="highlight sql"><figcaption><span>innodb_index_stats DDL</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `innodb_index_stats` (</span><br><span class="line">  `database_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `table_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `index_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `last_update` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `stat_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `stat_value` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `sample_size` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `stat_description` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`database_name`,`table_name`,`index_name`,`stat_name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin STATS_PERSISTENT<span class="operator">=</span><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="字段介绍-1"><a href="#字段介绍-1" class="headerlink" title="字段介绍"></a>字段介绍</h3><ul><li>database_name: 数据库名称；</li><li>table_name: 表名称；</li><li>index_name: 索引名称；</li><li>last_update: 更新时间；</li><li>stat_name: 统计信息名；</li><li>stat_value: 统计信息值；</li><li>sample_size: 采样大小；</li><li>stat_description: 类型说明；</li></ul><h3 id="统计项说明"><a href="#统计项说明" class="headerlink" title="统计项说明"></a>统计项说明</h3><p>如果翻看innodb_index_stats表数据，你会发现每个索引都会有多个统计项(stat_name)；主要如下：</p><table><thead><tr><th>stat_name统计项</th><th>stat_value含义</th></tr></thead><tbody><tr><td>size</td><td>索引的页数量</td></tr><tr><td>n_leaf_pages</td><td>叶子节点的数量</td></tr><tr><td>n_diff_pfxNN</td><td>索引上唯一值的数量；因为索引可能是多列，所以NN表示从左递增的列组合唯一值的数量；注意如果是普通索引除去自身索引列的统计，还会加上唯一索引列进行统计；</td></tr></tbody></table><p>了解stat_name和stat_value的具体含义，可以在解决或者优化慢查询问题上，起到一定的作用。如果统计值远小于实际值，查询优化器基本上不会选择该索引进行查询检索；</p><figure class="highlight md"><figcaption><span>n_diff_pfxNN举例说明</span></figcaption><table><tr><td class="code"><pre><span class="line">假设表有字段：a、b、c、d、e，唯一索引：uix<span class="emphasis">_a_</span>b<span class="emphasis">_c(a, b, c)， 普通索引：idx_</span>d<span class="emphasis">_e(d, e)；</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">针对唯一索引uix_</span>a<span class="emphasis">_b_</span>c则会有统计项： </span><br><span class="line"><span class="bullet">1.</span> n<span class="emphasis">_diff_</span>pfx01表示列a上的唯一值数量；</span><br><span class="line"><span class="bullet">2.</span> n<span class="emphasis">_diff_</span>pfx02表示a,b两列组合的唯一值数量；</span><br><span class="line"><span class="bullet">3.</span> n<span class="emphasis">_diff_</span>pfx03表示a,b,c三列组合的唯一值数量；</span><br><span class="line"></span><br><span class="line">针对普通索引：idx<span class="emphasis">_d_</span>e则会有统计项： </span><br><span class="line"><span class="bullet">1.</span> n<span class="emphasis">_diff_</span>pfx01表示d列上的唯一值数量；</span><br><span class="line"><span class="bullet">2.</span> n<span class="emphasis">_diff_</span>pfx02表示d, e两列组合的唯一值数量；</span><br><span class="line"><span class="bullet">3.</span> n<span class="emphasis">_diff_</span>pfx03表示d, e, a三列组合的唯一值数量；</span><br><span class="line"><span class="bullet">3.</span> n<span class="emphasis">_diff_</span>pfx04表示d, e, a, b四列组合的唯一值数量；</span><br><span class="line"><span class="bullet">3.</span> n<span class="emphasis">_diff_</span>pfx05表示d, e, a, b, c五列组合的唯一值数量；</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="手动更新统计信息"><a href="#手动更新统计信息" class="headerlink" title="手动更新统计信息"></a>手动更新统计信息</h2><p>执行ANALYZE TABLE table_name。注意：执行此语句时，需要保证用户拥有select和insert的权限；执行时，会持有innodb表的readonly锁，从而会短暂导致表的写入、更新、删除操作；</p><h2 id="统计信息不准确，怎么办？"><a href="#统计信息不准确，怎么办？" class="headerlink" title="统计信息不准确，怎么办？"></a>统计信息不准确，怎么办？</h2><p>如我的随笔中，<a href="../../2021-01-30/mysql-stats-info/">《什么？MySQL还有统计信息一说？》</a>一文中，有说到生产环境更新了索引，经过执行计划的查看，查询优化器并没有使用新建的索引；</p><p>运维查看了统计信息后，发现统计信息不准确，便执行ANALYZE TABLE table_name刷新了统计信息，便可以正常使用索引查询了。</p><p>所以，我们来整理下，如果发现索引没有正常被使用，发现和解决问题的大致思路。如有不适当的地方，欢迎大家留言点拨和斧正！</p><p><img src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/mysql-stats-info-explore/mysql_query_slow_ideas.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/mysql-stats-info-explore/mysql_query_slow_ideas.png" srcset="data:image/png;base64,666" alt="慢查询解决思路"></p><ul><li>第一步：检查索引是否建立起来，如果这步都漏了，是得好好反思下了；</li><li>第二步：索引正常建立，查询还是很慢，则查看执行计划，判断索引是否正常被使用；如果没被使用则走第三步，被使用了则走第四步；</li><li>第三步：索引正常建立，但是执行计划没有选择该索引；则查看统计信息，如果统计信息异常，则执行ANALYZE TABLE table_name刷新统计信息；还没有恢复，则调大采样变量大小；</li><li>第四步：索引正常建立，执行计划也选择了该索引，在SQL无问题的前提下需要考虑设计方面；</li></ul><p>注： 以上步骤建立在SQL没有问题的情况之上！</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么？MySQL还有统计信息一说？</title>
      <link href="/2021-01-30/mysql-stats-info/"/>
      <url>/2021-01-30/mysql-stats-info/</url>
      
        <content type="html"><![CDATA[<p>笔者最近在项目上对现有表进行了结构优化，并对一个常用表添加了索引。可谓测试环境玩漂移，生产环境怕翻车啊。上线验证的那一刻，突然发现一个类似报表功能的查询SQL极慢！</p><h1 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h1><ol><li><p>故障简查</p><p> 检查添加索引索引的SQL，查看SQL执行结果，检查DDL。一顿操作后，表象上没看出问题</p></li><li><p>比较执行计划</p><p> 连接sit环境执行explain，发现没问题，索引正常用上的。在生产的dbms上执行explain，发现索引没有用上，join查询时全表扫描了</p></li><li><p>查看MySQL版本</p><p> sit和prd环境都是5.7.22版本，看样子也不是版本不同造成的</p></li><li><p>再次分析</p><p> 既然MySQL版本也一样，DDL也一样，为啥执行计划就是不一样呢？一边猜测着是不是有什么缓存，一边为了节约发布时间，让运维帮忙先把索引删掉再重新添加下</p></li><li><p>问题暴露</p><p> 也许是运维对问题的普遍性或者敏感性，过了两三分钟，没对索引操作便通知我们好了！心里便纳了闷了，运维大牛确实牛啊！咨询了一番，便引出今天的话题了：刷新了<emp>统计信息</emp></p></li></ol><h1 id="统计信息研究"><a href="#统计信息研究" class="headerlink" title="统计信息研究"></a>统计信息研究</h1><p>笔者学识浅薄，未曾了解“统计信息”。特此奉上，统计信息研究！大神勿喷！</p><p>本文为随笔，具体的研究文章见：</p><div class="tag link"><a class="link-card" title="MySQL统计信息研究" href="https://joruachan.cn/2021-01-31/mysql-stats-info-explore/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/mysql-stats-info-explore/cover.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/mysql-stats-info-explore/cover.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">MySQL统计信息研究</p><p class="url">https://joruachan.cn/2021-01-31/mysql-stats-info-explore/</p></div></a></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纪实:nodejs+hexo+volantis快速构建个人Blog</title>
      <link href="/2021-01-17/fast-build-blog/"/>
      <url>/2021-01-17/fast-build-blog/</url>
      
        <content type="html"><![CDATA[<p>即使身为一个钢铁直男的技术人，能拥有一个分享自己技术心得和生活分享的小窝，想必是每个技术人都考虑过的事情吧!</p><p>笔者这就告诉你一个秘密：只需执行几行命令，改点配置，一个端庄不失典雅的博客网站就能生成好！</p><h2 id="搭建环境简介"><a href="#搭建环境简介" class="headerlink" title="搭建环境简介"></a>搭建环境简介</h2><p>nodejs + hexo;</p><p>nodejs的安装本文不再介绍，不熟悉的同学可前往<a href="https://nodejs.org/">nodejs官网</a>学习并安装；本站选用hexo的volantis主题介绍建站的， hexo提供了330款主题，如有需要，<a href="https://hexo.io/themes/">可前往查看其他主题</a></p><div class="tag link"><a class="link-card" title="NodeJs" href="https://nodejs.org/en/"><div class="left"><img src="https://nodejs.org/static/images/logo.svg" class="lazyload" data-srcset="https://nodejs.org/static/images/logo.svg" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">NodeJs</p><p class="url">https://nodejs.org/en/</p></div></a></div><div class="tag link"><a class="link-card" title="Hexo" href="https://hexo.io/"><div class="left"><img src="https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg" class="lazyload" data-srcset="https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">Hexo</p><p class="url">https://hexo.io/</p></div></a></div><div class="tag link"><a class="link-card" title="Volantis" href="https://volantis.js.org/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">Volantis</p><p class="url">https://volantis.js.org/</p></div></a></div><h2 id="hexo简介"><a href="#hexo简介" class="headerlink" title="hexo简介"></a>hexo简介</h2><p><a href="https://hexo.io/">hexo</a> 自称为：快速、简洁且高效的博客框架。</p><p>笔者用起来确实还可以，大概介绍下几个特性：</p><ul><li>提供了不同的layout，可将文章存为草稿，需要时publish即可；</li><li>可维护全局的数据，在source/_data文件夹下添加yaml文件，通过site.data获取；</li><li>可指定文件的特有变量，通过<a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a>实现；</li><li>支持模板，在scaffolds文件夹下可自定义模板，并进行发布；</li><li>支持标签插件，可以在文章文件中使用标签%%来插入特定内容；</li><li>提供<a href="https://hexo.io/zh-cn/docs/commands">命令行操作</a>，如：hexo init初始化项目、hexo new新建文章、hexo pulish发布草稿文件、hexo generate生成静态文件、hexo server启动服务器；</li></ul><h2 id="hexo搭建博客步骤"><a href="#hexo搭建博客步骤" class="headerlink" title="hexo搭建博客步骤"></a>hexo搭建博客步骤</h2><ol><li>前提是必须安装好git和nodejs；</li><li>执行 “npm install -g hexo-cli”，安装好hexo；</li><li>选定文件夹，通过 “hexo init $folder” 初始化一个名为 $folder 的文件夹；</li><li>cd $folder, 再执行npm install，至此hexo的博客框架已经搭建完成！</li></ol><p>完成上述步骤后，可执行hexo server, 访问<a href="http://localhost:4000/">http://localhost:4000</a>, 会发现一个HelloWorld页面已经可以访问！</p><p><img src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/fast-build-blog/hexo_build_page.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/fast-build-blog/hexo_build_page.png" srcset="data:image/png;base64,666" alt="初步搭建页面"></p><h2 id="选用volantis主题"><a href="#选用volantis主题" class="headerlink" title="选用volantis主题"></a>选用volantis主题</h2><ol><li>设置项目使用的主题: 项目根目录下的_config.yml文件中设置 theme: volantis;</li><li>如果Hexo版本在5.0.2及以上，可以直接通过npm i hexo-theme-volantis进行安装；笔者为了项目的可读性，采用了源代码拷贝到theme文件夹的方案（记得删除.git文件夹,否则git提交时会出问题!）</li><li>按照依赖的插件：npm i hexo-generator-search hexo-generator-json-content(站内搜索)，npm i hexo-renderer-stylus（Stylus 渲染器）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/fast-build-blog/volantis_config.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/fast-build-blog/volantis_config.png" srcset="data:image/png;base64,666" alt="volantis配置"></p><p>完成上述步骤后执行hexo server, 访问<a href="http://localhost:4000/">http://localhost:4000</a>, 是不是发现端庄不失典雅的博客网站已经完成了！</p><p><img src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/fast-build-blog/volantis_preview.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/fast-build-blog/volantis_preview.png" srcset="data:image/png;base64,666" alt="volantis预览"></p><h2 id="尝试新建文章"><a href="#尝试新建文章" class="headerlink" title="尝试新建文章"></a>尝试新建文章</h2><p>执行 hexo new post $newPostName，会在_post文件夹下新建一个名为$newPostName的md文件，一个新的文章便建立完成。</p><p>这时你只需要关注你的博文输出即可啦！</p><p><img src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/fast-build-blog/new_post.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/fast-build-blog/new_post.png" srcset="data:image/png;base64,666" alt="newPost"></p><h2 id="发布至GitHub-Pages"><a href="#发布至GitHub-Pages" class="headerlink" title="发布至GitHub Pages"></a>发布至GitHub Pages</h2><p>如果你期望能通过GitHub Pages来访问你的博客网站，做如下几步：</p><ol><li>通过GitHub新建一个repository，名为：&lt;你的 GitHub 用户名&gt;.github.io；</li><li>本地检出该repository；</li><li>在博客源码的项目中执行命令：hexo generate –deploy，会生成public文件夹，该文件夹里便是博客所有的静态页面文件；</li><li>将public文件夹中的文件全部拷贝到新建repository的master分支下；</li><li>将master文件推送至远程master分支即可！</li><li>静待一会，访问：http://&lt;你的 GitHub 用户名&gt;.github.io便能访问你自定义的博客了！</li></ol><div class="note paperclip"><p>如果你有自己的域名，可以在域名解析配置成 记录类型：CNAME，记录值：&lt;你的 GitHub 用户名&gt;.github.io。 注意了！！！ 此时还需要在GitHub Page项目中根目录下加上名为CNAME的文件，文件内容为你自己的域名。</p></div><p>正如你看到的，搭建一个个人博客网站就是如此便捷！</p><p>如果你喜欢的话，点个赞，分享分享下吧！谢谢~</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
