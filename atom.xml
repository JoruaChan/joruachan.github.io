<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JoruaChan技术博客</title>
  
  <subtitle>永远不甘于现状</subtitle>
  <link href="http://joruachan.cn/atom.xml" rel="self"/>
  
  <link href="http://joruachan.cn/"/>
  <updated>2022-08-17T16:10:59.667Z</updated>
  <id>http://joruachan.cn/</id>
  
  <author>
    <name>JoruaChan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux动态库</title>
    <link href="http://joruachan.cn/2022-08-17/dynamiclibrary/"/>
    <id>http://joruachan.cn/2022-08-17/dynamiclibrary/</id>
    <published>2022-08-17T15:56:55.000Z</published>
    <updated>2022-08-17T16:10:59.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="so文件命名规则"><a href="#so文件命名规则" class="headerlink" title="so文件命名规则"></a>so文件命名规则</h2><p>libname.so.x.y.z</p><ul><li>x：major version主版本号，不同major version之间库不兼容；</li><li>y：minor version次版本号，增量更新，一般增加新接口，原接口不变，从高到低版本是兼容的；</li><li>z：release version发布版本号，bug修复、性能改进等，不添加新接口，不改变原接口；</li></ul><p>看到的只有一个主版本号的so文件，一般是有软连接到libname.so.x.y.z；</p><h2 id="动态库和操作系统的关系"><a href="#动态库和操作系统的关系" class="headerlink" title="动态库和操作系统的关系"></a>动态库和操作系统的关系</h2><h3 id="动态库搜索路径配置"><a href="#动态库搜索路径配置" class="headerlink" title="动态库搜索路径配置"></a>动态库搜索路径配置</h3><p>/etc/ld.so.conf，告诉操作系统文件去哪搜索动态库。内容如下：<code>include /etc/ld.so.conf.d/*.conf</code><br />ld.so.conf.d文件夹下有：libc.conf、x86_64-linux-gnu.conf；</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22810517/1659886410578-b4352338-7d5c-42cc-bbf1-ca8a0ac1213e.png#clientId=u8663e778-a8ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=308&id=tGRqF&margin=%5Bobject%20Object%5D&name=image.png&originHeight=616&originWidth=812&originalType=binary&ratio=1&rotation=0&showTitle=false&size=83356&status=done&style=stroke&taskId=uc84c3dcb-7888-4177-b62e-5c3248a9bc0&title=&width=406" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/22810517/1659886410578-b4352338-7d5c-42cc-bbf1-ca8a0ac1213e.png#clientId=u8663e778-a8ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=308&id=tGRqF&margin=%5Bobject%20Object%5D&name=image.png&originHeight=616&originWidth=812&originalType=binary&ratio=1&rotation=0&showTitle=false&size=83356&status=done&style=stroke&taskId=uc84c3dcb-7888-4177-b62e-5c3248a9bc0&title=&width=406" srcset="data:image/png;base64,666" alt="image.png"></p><h3 id="ldconfig链接缓存"><a href="#ldconfig链接缓存" class="headerlink" title="ldconfig链接缓存"></a>ldconfig链接缓存</h3><p>ldconfig是动态链接库管理命令。在默认搜寻目录/lib和/usr/lib，以及配置文件/etc/ld.so.conf所列目录下，搜索出可共享的动态链接库。<br /><strong>创建出动态装入程序所需的软连接，并生成cache缓存文件到/etc/ld.so.cache（缓存了已排好序的动态库名称列表）</strong></p><p>在lib下安装新的库，或者修改/etc/ld.so.conf文件，需要调用ldconfg更新；</p><h3 id="LD-LIBRARY"><a href="#LD-LIBRARY" class="headerlink" title="LD_LIBRARY"></a>LD_LIBRARY</h3><p>当没有权限或者不想修改文件时候，可以使用LD_LIBRARY环境变量指定查找动态库搜寻路径；</p><p>如果同一个动态库有多个版本，可以利用不同用户定义不同的LD_LIBRARY环境变量，从而依赖不同的环境变量而使用不同版本的动态库；</p><h3 id="搜寻顺序"><a href="#搜寻顺序" class="headerlink" title="搜寻顺序"></a>搜寻顺序</h3><ul><li>LD_LIBRARY环境变量的路径；</li><li>/etc/ld.so.cache缓存文件的缓存内容；</li><li>/usr/lib和/lib；</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>ldconfig只是在运行时有关。gcc编译时候还要使用-L指定搜寻路径，-l表示库名；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;so文件命名规则&quot;&gt;&lt;a href=&quot;#so文件命名规则&quot; class=&quot;headerlink&quot; title=&quot;so文件命名规则&quot;&gt;&lt;/a&gt;so文件命名规则&lt;/h2&gt;&lt;p&gt;libname.so.x.y.z&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x：major version主</summary>
      
    
    
    
    <category term="linux" scheme="http://joruachan.cn/categories/linux/"/>
    
    
    <category term="操作系统" scheme="http://joruachan.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>chat_with_you</title>
    <link href="http://joruachan.cn/2022-06-12/chat/index/"/>
    <id>http://joruachan.cn/2022-06-12/chat/index/</id>
    <published>2022-06-12T14:24:56.000Z</published>
    <updated>2022-06-12T14:24:56.983Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring动态代理</title>
    <link href="http://joruachan.cn/2022-03-27/springproxy/"/>
    <id>http://joruachan.cn/2022-03-27/springproxy/</id>
    <published>2022-03-27T15:03:18.000Z</published>
    <updated>2022-08-17T16:06:04.076Z</updated>
    
    <content type="html"><![CDATA[<p>Spring中动态代理，实现方式有两种：Jdk动态代理、Cglib动态代理；而在SpringFramework中，又是AOP模块应用了动态代理的能力实现面向切面编程；</p><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><ol><li>Spring中，如果一个类实现了接口，AOP拦截了非接口方法，会怎么处理？</li><li>Spring中，依赖注入一个被AOP拦截的实现类，会怎么处理？</li><li>Spring如何启动AOP功能？ </li><li>Spring如何生成代理bean？ </li><li>Spring IoC容器中，被代理的target在什么地方？</li></ol><h2 id="AOP（动态代理的实现）"><a href="#AOP（动态代理的实现）" class="headerlink" title="AOP（动态代理的实现）"></a>AOP（动态代理的实现）</h2><p>AOP，面向切面编程；只需要关注业务代码，抽取出重复的事务处理、日志记录、缓存等逻辑代码。</p><h3 id="基础概念释义"><a href="#基础概念释义" class="headerlink" title="基础概念释义"></a>基础概念释义</h3><h4 id="Aspect切面"><a href="#Aspect切面" class="headerlink" title="Aspect切面"></a>Aspect切面</h4><p>我理解的切面，应该就是一种声明，声明AOP处理逻辑的集合。如@Aspect注解是声明切面， 包含了Pointcut、Advice等等；</p><h4 id="JoinPoint连接点"><a href="#JoinPoint连接点" class="headerlink" title="JoinPoint连接点"></a>JoinPoint连接点</h4><p>连接点，可以理解成程序中方法调用的地方，也可以是异常处理的地方；</p><h4 id="Advice通知"><a href="#Advice通知" class="headerlink" title="Advice通知"></a>Advice通知</h4><p>定义了在pointcut切点处的处理逻辑，同时也定义在切点执行的前或后或特殊情况进行拦截。主要有BeforeAdvice、AfterAdvice（AfterReturningAdvice、ThrowsAdvice）。另外还有继承Advice的拦截器Interceptor（拦截器和Advice的区别？？）</p><h3 id="AOP联盟概念释义"><a href="#AOP联盟概念释义" class="headerlink" title="AOP联盟概念释义"></a>AOP联盟概念释义</h3><p>下图列出了，SpringFramework中Aop实现源代码。其中org.aopallicance包下面是AOP联盟定义的标准化接口，可以从maven public仓库自行依赖aopalliance.jar查看，会发现和Spring中引入的是一致的。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/springproxy/springaop-directory.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/springproxy/springaop-directory.png" srcset="data:image/png;base64,666" alt="SpringAop源码"/></div><span class="image-caption">SpringAop源码</span></div><figure class="highlight xml"><figcaption><span>aop maven依赖</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>aopalliance<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aopalliance<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Interceptor-拦截器"><a href="#Interceptor-拦截器" class="headerlink" title="Interceptor 拦截器"></a>Interceptor 拦截器</h4><p>对Advice概念进一步细化。继承于Advice接口，表示以拦截的方式实现Advice；子接口MethodInterceptor方法拦截器、ConstructorInterceptor构造器拦截器，分别表示对方法和构造函数的拦截处理；</p><h4 id="Invocation调用"><a href="#Invocation调用" class="headerlink" title="Invocation调用"></a>Invocation调用</h4><p>对Joinpoint概念进一步细化。继承于JoinPoint接口，调用连接点，即程序中的调用，表示可以被Interceptor拦截的连接点；子接口MethodInvocation方法调用连接点、ConstructorInvocation构造器调用连接点，分别表示方法、构造器被调用的连接点；</p><h3 id="Spring-AOP概念释义"><a href="#Spring-AOP概念释义" class="headerlink" title="Spring AOP概念释义"></a>Spring AOP概念释义</h3><p>SpringAOP并不是自立门户，而是在AOP联盟基础上进行拓展封装；</p><h4 id="Pointcut切点"><a href="#Pointcut切点" class="headerlink" title="Pointcut切点"></a>Pointcut切点</h4><p>Pointcut，joinpoint连接点集合，用通配、正则表达式来声明这些需要拦截的点；定义了Advice将要发生的地方；</p><figure class="highlight java"><figcaption><span>Pointcut源码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return the ClassFilter for this pointcut.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the ClassFilter (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ClassFilter <span class="title">getClassFilter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 通过MethodMatcher来匹配被拦截的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Canonical Pointcut instance that always matches.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Pointcut TRUE = TruePointcut.INSTANCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Advisor通知器"><a href="#Advisor通知器" class="headerlink" title="Advisor通知器"></a>Advisor通知器</h4><p>Advisor是Advice通知和Pointcut切点的集合，常用的Advisor是DefaultPointcutAdvisor；通过某个具体的Advisor就可以知道在某个方法、注解等切点做什么拦截处理；</p><h4 id="Introduction-引入"><a href="#Introduction-引入" class="headerlink" title="Introduction 引入"></a>Introduction 引入</h4><p>见IntroductionInfo接口，其目的是为了给目标对象引入指定的接口，拓展代理时的逻辑，如状态校验、锁校验等。Advice、Interceptor以及Advisor都有Introduction的身影；</p><ul><li>DynamicIntroductionAdvice：其implementsInterface方法指定引入哪些接口；</li><li>IntroductionInterceptor：继承接口MethodInterceptor、DynamicIntroductionAdvice，可以理解成当拦截了某个方法时候引入接口处理，而不是直接进行代理；</li><li>DelegatingIntroductionInterceptor：实现IntroductionInterceptor的implementsInterface和invoke两个方法，通过构造函数传递引入的接口实现对象，默认为自己；</li><li>DefaultIntroductionAdvisor：默认用于实现引入的Advisor，构造函数传入IntroductionInterceptor、引入的接口；</li></ul><p><strong><em>注意：</em></strong><em>Spring中默认情况是不会使用Introduction引入的，可以使用ProxyFactoryBean来封装对Introduction的创建！如果想给所有的Proxy都添加引入，直接声明IntroductionInterceptor类型的Bean即可。</em></p><p><em>存疑：ProxyFactoryBean的interceptorName的作用和全局的Interceptor冲突吗？</em></p><p>看这篇：<a href="https://chova.blog.csdn.net/article/details/107283525">https://chova.blog.csdn.net/article/details/107283525</a></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>Spring没有实现AOP联盟的ConstructorInterceptor和ConstructorInvocation，所以<strong>Spring只支持方法调用的拦截，不支持构造器的拦截。（如果需要构造器、属性的拦截处理，需要考虑AspectJ来实现切面）</strong></p><h3 id="AOP实现方式"><a href="#AOP实现方式" class="headerlink" title="AOP实现方式"></a>AOP实现方式</h3><h4 id="方法一：回调"><a href="#方法一：回调" class="headerlink" title="方法一：回调"></a>方法一：回调</h4><p>如Servlet中定义的Filter过滤器和Interceptor拦截器；</p><h4 id="方法二：代理"><a href="#方法二：代理" class="headerlink" title="方法二：代理"></a>方法二：代理</h4><p>静态代理、动态代理；</p><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h3><p>AnnotationAwareAspectJAutoProxyCreator，适用于使用@Aspect等注解声明切面的自动代理类。主要完成Advisor的解析、适配针对Bean的Advisor、生成Bean的代理对象；当然，很多功能是由父类定义和完成的，子类完成实现。其类继承关系如下图：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/springproxy/annotationajapc.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/springproxy/annotationajapc.png" srcset="data:image/png;base64,666" alt="AnnotationAwareAspectJAutoProxyCreator类关系"/></div><span class="image-caption">AnnotationAwareAspectJAutoProxyCreator类关系</span></div><h4 id="如何解析成BeanDefinition注册到BeanFactory？"><a href="#如何解析成BeanDefinition注册到BeanFactory？" class="headerlink" title="如何解析成BeanDefinition注册到BeanFactory？"></a>如何解析成BeanDefinition注册到BeanFactory？</h4><p>BeanDefinitionParserDelegate#parseCustomElement方法中，会通过DefaultNamespaceHandlerResolver #resolve，实例化AopNamespaceHandler，再通过init()方法实例化AOP相关的解析器，如<strong>AspectJAutoProxyBeanDefinitionParser</strong>；</p><p>AspectJAutoProxyBeanDefinitionParser会解析并得到名字为“org.springframework.aop .config.internalAutoProxyCreator”的BeanDefinition，并添加proxyTargetClass和exposeProxy属性；</p><p><strong><em>注意：</em></strong><em>如果定义了多个，最终只有一个能使用。按照AnnotationAwareAspectJAutoProxyCreator &gt;&gt; AspectJAwareAdvisorAutoProxyCreator &gt;&gt; InfrastructureAdvisorAutoProxyCreator的优先级进行注册；</em></p><h4 id="何时-amp-如何实例化？"><a href="#何时-amp-如何实例化？" class="headerlink" title="何时&amp;如何实例化？"></a>何时&amp;如何实例化？</h4><p>AbstractApplicationContext#registerBeanPostProcessors方法中，会通过工具类的静态方法PostProcessorRegistrationDelegate#registerBeanPostProcessors来实例化并注册所有的BeanPostProcessor；AnnotationAwareAspectJAutoProxyCreator就是一个BeanPostProcessor。</p><h4 id="如何解析Advisor？"><a href="#如何解析Advisor？" class="headerlink" title="如何解析Advisor？"></a>如何解析Advisor？</h4><ol><li>获取所有Advisor：当getBean时，会执行AnnotationAwareAspectJAutoProxyCreator这个BeanPostProcessor的postProcessAfterInitialization方法，主要是执行AbstractAutoProxyCreator的wrapIfNecessary()方法；通过<strong>AbstractAdvisorAutoProxyCreator#findCandidateAdvisors</strong>得到全局的Advisor集合；</li><li>找到适合增强Bean的Advisor：调用**AbstractAdvisorAutoProxyCreator#findAdvisorsThatCanApply()**找到适合增强这个Bean的Advisor；</li></ol><p>获取所有的Advisor：</p><ul><li><strong>BeanFactoryAdvisorRetrievalHelper</strong>，从BeanFactory中找到所有Advisor类型的Bean，findAdvisorBeans()首次会从IoC容器中找到所有的Advisor（按照beanName作为缓存，而不是直接用Bean缓存，应该是为了适应每个Bean的作用域把），再根据所有的beanName循环调用getBean()，返回getBean得到的Advisor对象；</li><li><strong>BeanFactoryAspectJAdvisorBuilder</strong>，遍历所有注册的Bean，并获取被@Aspect注解的类进行解析，得到所有的Advisor类型的Bean对象；buildAspectJAdvisors()首次会扫描所有注册的Bean找到Aspect相关类，解析@Aspect类得到Advisor Bean对象；如果bean是单例则直接缓存Advisor对象，如果不是则缓存工厂；</li></ul><h4 id="类关系？"><a href="#类关系？" class="headerlink" title="类关系？"></a>类关系？</h4><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/springproxy/springproxyclasses.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/springproxy/springproxyclasses.png" srcset="data:image/png;base64,666" alt="AutoProxyCreator的类关系"/></div><span class="image-caption">AutoProxyCreator的类关系</span></div><h4 id="如何生成代理对象？"><a href="#如何生成代理对象？" class="headerlink" title="如何生成代理对象？"></a>如何生成代理对象？</h4><p>（在整个Bean生命周期如何运作的？在循环依赖问题中如何应用的？）<br>Advisor类型的对象何时且如何注入并生成的？Aspect具体是如何根据Bean找到Advisor的（BeanFactoryAspectAdvisorsBuilder）？</p><h3 id="MethodInvocation"><a href="#MethodInvocation" class="headerlink" title="MethodInvocation"></a>MethodInvocation</h3><p>ProxyMethodInvocation、ReflectiveMethodInvocation</p><h3 id="MethodInterceptor"><a href="#MethodInterceptor" class="headerlink" title="MethodInterceptor"></a>MethodInterceptor</h3><p>IntroductionInterceptor</p><h3 id="执行逻辑（原理）"><a href="#执行逻辑（原理）" class="headerlink" title="执行逻辑（原理）"></a>执行逻辑（原理）</h3><h2 id="Spring-AOP与AspectJ的关系"><a href="#Spring-AOP与AspectJ的关系" class="headerlink" title="Spring AOP与AspectJ的关系"></a>Spring AOP与AspectJ的关系</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring中动态代理，实现方式有两种：Jdk动态代理、Cglib动态代理；而在SpringFramework中，又是AOP模块应用了动态代理的能力实现面向切面编程；&lt;/p&gt;
&lt;h2 id=&quot;问题引入&quot;&gt;&lt;a href=&quot;#问题引入&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="动态代理" scheme="http://joruachan.cn/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
    <category term="Java面试复习" scheme="http://joruachan.cn/tags/Java%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="Spring" scheme="http://joruachan.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JDK动态代理</title>
    <link href="http://joruachan.cn/2022-03-01/jdkproxy/"/>
    <id>http://joruachan.cn/2022-03-01/jdkproxy/</id>
    <published>2022-02-28T16:00:00.000Z</published>
    <updated>2022-08-17T16:05:57.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><ol><li>如果不同接口，同方法名、同参数、不同返回值怎么代理的？</li><li>如果接口整体一致但顺序不一致，使用的是同一个代理类吗？</li><li>如果传入非接口类、重复接口类，会怎么处理？</li><li>如果存在非公有的接口类，会怎么处理？</li></ol><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><h3 id="Proxy-newProxyInstance"><a href="#Proxy-newProxyInstance" class="headerlink" title="Proxy.newProxyInstance"></a>Proxy.newProxyInstance</h3><figure class="highlight java"><figcaption><span>Jdk创建代理类调用方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span><br></pre></td></tr></table></figure><h4 id="入参"><a href="#入参" class="headerlink" title="入参"></a>入参</h4><p>loader：指定类加载器；<br>interfaces：代理类实现的接口；<br>h：代理方法调用处理接口InvocationHandler；</p><h4 id="返参"><a href="#返参" class="headerlink" title="返参"></a>返参</h4><p>Object：Proxy子类，即生成的代理类；</p><h4 id="方法逻辑"><a href="#方法逻辑" class="headerlink" title="方法逻辑"></a>方法逻辑</h4><ul><li>第一步：权限校验；</li></ul><p>涉及到了三个类加载器：调用newProxyInstance方法的类的类加载器c1、指定加载代理类的加载器c2、接口所在的类加载器c3；主要是做三者间的权限校验；</p><p>校验类加载器间的权限，即Class#getClassLoader；如果c2是bootstrap类加载器，c1不是，要看c1有没有getClassLoader的权限；</p><p>校验接口所在包的访问权限，当前类加载器是否存在接口类所在package的访问权限。如果没有访问权限，即接口非公有，那么必须c1=c2=c3。<strong>公有的都是放在com.sun.proxy包中；</strong></p><ul><li>第二步：生成并缓存代理类Class对象；</li></ul><p>实际就是调用WeakCache#get方法获取；WeakCache可以理解成缓存代理类的容器，由两级ConcurrentHashMap实现缓存机制，完成代理类Class对象的获取；</p><p>第一级key是<strong>CacheKey对象，ClassLoader的弱引用对象</strong>；expungeStaleEntries()方法，会从ReferenceQueue.poll出CacheKey，并将弱引用对象从map中清除、将缓存的Class对象清除；</p><p>第二级key是Proxy.KeyFactory#apply返回的Key0,Key1,Key2,KeyX对象，0、1、2、x针对的是被代理接口的数量；<strong>这些Key其实是由被代理类的接口类集合组成的弱引用；每个对象都会作为弱引用；</strong></p><p>第二级value，在初始化的时刻会是WeakCache.Factory对象，当调用Factory#get方法得到Class（其实就是ProxyClassFactory#apply得到的对象）后，<strong>将Class对象包装成弱引用CacheValue，这个CacheValue会取代Factory作为第二级value；</strong>通过循环，保证最终拿到的肯定是CacheValue包装的Class对象。可以参考源码在并发和失败情况下的代码处理。</p><ul><li>第三步：生成代理对象；</li></ul><p>根据第二步得到的Class对象，获取Proxy(InvocationHandler h)的构造函数，通过反射生成代理对象；</p><h3 id="Proxy-ProxyClassFactory"><a href="#Proxy-ProxyClassFactory" class="headerlink" title="Proxy.ProxyClassFactory"></a>Proxy.ProxyClassFactory</h3><ol><li>校验</li></ol><p>通过Class.forName方法校验接口类能否被代理类加载器加载；是否接口有重复的；</p><ol start="2"><li>确认代理的包位置</li></ol><ul><li>接口都是public，放到com.sun.proxy包下面，访问修饰符为public final；</li><li>存在非public接口，校验非public接口是不是在同一个包，是则放入非公有接口类的包下，不是则抛异常；</li></ul><ol start="3"><li>生成字节码</li></ol><p>通过<strong>ProxyGenerator#generateProxyClass</strong>获取字节码的二进制数据；</p><ol start="4"><li>类加载</li></ol><p>通过<strong>Proxy#defineClass0本地方法</strong>，将字节码二进制数据加载成Class对象；</p><h3 id="ProxyGenerator"><a href="#ProxyGenerator" class="headerlink" title="ProxyGenerator"></a>ProxyGenerator</h3><p>ProxyGenerator，参数存的都是待生成代理类的修饰符、常量池、方法、参数；</p><h4 id="generateProxyClass静态方法"><a href="#generateProxyClass静态方法" class="headerlink" title="generateProxyClass静态方法"></a>generateProxyClass静态方法</h4><p><code>**public static byte**[] generateProxyClass(**final **String name,  Class&lt;?&gt;[] interfaces, **int **accessFlags)</code></p><p>通过ProxyGenerator生成字节码二进制数据，如果希望保留生成的二进制数据到文件中，可以指定JVM参数sun.misc.ProxyGenerator.saveGeneratedFiles为true；</p><h4 id="generateClassFile实例方法"><a href="#generateClassFile实例方法" class="headerlink" title="generateClassFile实例方法"></a>generateClassFile实例方法</h4><ol><li>添加ProxyMethod</li></ol><ul><li>添加Object的hashCode、equals、toString方法；（优先于代理类中的方法）</li><li>添加所有接口中的方法，生成ProxyMethod加入List中并到Map缓存，如果存在同签名、同返回值的方法则确认最大异常集合；</li></ul><ol start="2"><li>检查相同方法签名的代理方法；</li></ol><p>如果存在大于2个相同签名的方法，那么所有的返回类型都<strong>必须是引用类型（不可是基础类型！）</strong>，并且必须有一个可以<strong>作为其余所有返回类型的子类</strong>； </p><ol start="3"><li>添加字节码需要的方法信息、参数信息；</li></ol><ul><li>方法：类构造方法、代理方法（将ProxyMethod转成MethodInfo，用于生成class文件）、静态方法块（完成静态参数Method的初始化）；</li><li>参数：全部是private static修饰的所有代理方法对应的Method对象；即private static Method xxxxxx；</li></ul><ol start="4"><li>更新常量池的索引；</li></ol><p>代理类$Proxy、代理类父类Proxy、被代理的接口类；</p><ol start="5"><li>根据字节码规范生成class二进制数据；</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过动态生成并缓存Proxy子类，代理所有接口中方法，方法内部调用InvocationHandler实例的invoke方法，传递被代理的Method。所以在InvocationHandler实现类的invoke方法中，要有被代理的实例，并且通过Method#invoke完成代理。InvocationHandler#invoke的返回值，应对应具体接口的返回值；</p><h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ol><li>类只要实现接口，Spring就会使用JDK动态代理，不论Bean声明时候用的接口类还是实现类；</li><li>如果使用JDK代理，只能代理接口中定义的方法。因为通过JDK代理生成的类型是Proxy子类，是无法强转成实现类的，就无法完成代理；Proxy.newProxyInstance源码其实也分析了，生成的class代码里，只针对接口的方法生成了Method；</li><li>equals/hashCode方法，JdkDynamicAopProxy会处理；</li><li>如果类实现了接口，然后AOP拦截了该类的非接口方法，此时该对象会被创建JDK代理。但是此时没办法执行AOP的Adviced；因为JDK代理不会代理非接口方法。并且如果这个类被其他对象依赖，Spring启动会校验并报错！</li><li>由于JDK动态代理生成的是Proxy的子类，所以当使用了AOP相关功能时，依赖注入要注意不可以直接用实现类，而得改用接口+名字来找到具体Bean；或者强制使用Cglib生成子类代理；</li><li>如果方法的返回值是this自己，会将返回值改成代理！</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题引入&quot;&gt;&lt;a href=&quot;#问题引入&quot; class=&quot;headerlink&quot; title=&quot;问题引入&quot;&gt;&lt;/a&gt;问题引入&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;如果不同接口，同方法名、同参数、不同返回值怎么代理的？&lt;/li&gt;
&lt;li&gt;如果接口整体一致但顺序不一致，使用的是</summary>
      
    
    
    
    
    <category term="动态代理" scheme="http://joruachan.cn/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
    <category term="Java面试复习" scheme="http://joruachan.cn/tags/Java%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《见识》读后感</title>
    <link href="http://joruachan.cn/2022-01-23/after-reading-jianshi/"/>
    <id>http://joruachan.cn/2022-01-23/after-reading-jianshi/</id>
    <published>2022-01-23T15:36:01.000Z</published>
    <updated>2022-08-17T16:06:04.074Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第二章-人生需要做减法"><a href="#第二章-人生需要做减法" class="headerlink" title="第二章 人生需要做减法"></a>第二章 人生需要做减法</h3><h4 id="西瓜与芝麻"><a href="#西瓜与芝麻" class="headerlink" title="西瓜与芝麻"></a>西瓜与芝麻</h4><p><em><strong>内容精采</strong></em></p><ul><li>社会上太多捡芝麻的人，不仅时间利用得没有效率，而且渐渐习惯于非常低层次的追求！如花大量的时间或精力来捡芝麻；</li><li>公司和个人一样，专注西瓜去捡，目光放得更长远；</li><li>聚焦”练就捡西瓜的能力”，从同事中脱颖而出；</li><li>致力于捡西瓜，那就要耐得住寂寞；</li></ul><p><strong><em>我的想法</em></strong></p><ul><li>做哪些：有时候，想做的事情太多了，但是每个人自己除了工作外，可用时间是数得过来的。不妨把你想做的事情列出来，然后按照重要性、必要性等关注的要素来进行分类、排序，再按照顺序一件件解决。从而过滤掉”芝麻”，而着重完成”西瓜”；</li><li>如何做：先做好较为宽松的计划，保证存在可应付的突发情况下能完成目标计划。耐得住寂寞，想起周董的《听妈妈的话》，当别人在玩耍的时候，你能耐得住寂寞来”捡西瓜”；</li></ul><h4 id="生也有涯，知也无涯"><a href="#生也有涯，知也无涯" class="headerlink" title="生也有涯，知也无涯"></a>生也有涯，知也无涯</h4><p><em><strong>内容精采</strong></em></p><ul><li>庄子在《养生主》开篇讲：”吾生也有涯，而知也无涯，以有涯随无涯，殆矣。已而为知者，殆而已矣。”；</li><li>跳出原有的思维定式，考虑如何少做事，而不是让自己更忙碌；</li><li>初创公司也是如此，小公司资源有限，必须将人力集中到一个点上，学会做减法；</li></ul><h4 id="我们一定比18世纪的人过得好吗？"><a href="#我们一定比18世纪的人过得好吗？" class="headerlink" title="我们一定比18世纪的人过得好吗？"></a>我们一定比18世纪的人过得好吗？</h4><p><em><strong>内容精采</strong></em></p><ul><li>当今的贵族社会阶层基本上不存在了，但是不等于贵族的精神和生活方式不存在；</li><li>贵族的生活讲究从容、自律和优雅，令人向往的气质和自信来源于内心在用责任和荣誉对自己进行约束，对外则展示出从容和优雅，这些是幸福生活的根本；</li><li>人的幸福来源，除了基因的传承、成就的影响力，还有爱情和婚姻、对未来的期望以及生活的态度三个维度；</li><li>每天想到”责任””荣誉””从容””优雅””镇定”这10个字，就能过得比18世纪的贵族更好；</li></ul><h3 id="第三章-谈谈见识"><a href="#第三章-谈谈见识" class="headerlink" title="第三章 谈谈见识"></a>第三章 谈谈见识</h3><h4 id="我们和天才相差有多远？"><a href="#我们和天才相差有多远？" class="headerlink" title="我们和天才相差有多远？"></a>我们和天才相差有多远？</h4><p><em><strong>内容精采</strong></em></p><ul><li>看不出智力和成就有完全正相关的关系；</li><li>为什么那么多人不缺乏智商、受过良好的教育，也足够努力，成就却要比那些诺贝尔奖获得者，或者其他有成就者差很多呢？一个解释就是智商或者在解决难题中所表现出的智力，和真正的聪明并不完全是线性正相关的；另一种解释是，天才的大脑和我们常人在生理上有一些明显的不同。（爱因斯坦的大脑切片经过各国科学家的研究并未发现和常人有太多的不同）</li><li>爱因斯坦和常人三个最大的不同：善于提出问题、爱思考并总结规律、非常有恒心；</li><li>凡天才必有过人之处，但是我们和他们之间的差异可能不是生理上的差距，而是在其他方面，比如认识上、见识上、勇气上或方法上；</li></ul><h3 id="第四章-大家智慧"><a href="#第四章-大家智慧" class="headerlink" title="第四章 大家智慧"></a>第四章 大家智慧</h3><h4 id="莎士比亚的智慧：论朋友"><a href="#莎士比亚的智慧：论朋友" class="headerlink" title="莎士比亚的智慧：论朋友"></a>莎士比亚的智慧：论朋友</h4><p><em><strong>内容精采</strong></em></p><ul><li>朋友的交往其实也是一种投资。由于基因的局限性，我们很难同时交往超过150个人；（邓巴圈的人数，一般人类认知能力的限制会保持在100-250人，大多是150人）</li><li>成功的交友是人一生最重要的投资；</li><li>莎士比亚在《哈姆雷特》有说，”凡事三思而行，不要想到什么就说什么”、”对人要和气，但不要过分狎昵”、”相知有素的朋友，应该用钢圈箍在你的灵魂上，可是不要对每一个泛泛的新知滥施你的交情”；</li><li>你如果问我是怎么做的，我用的是曾国藩的一个原则，简单地讲就是<strong>不要给损友第二次机会，永远不要来往；</strong></li></ul><p><code>狎昵释义：过于亲近而态度不庄重；</code></p><h4 id="拉里·佩奇的经营管理智慧"><a href="#拉里·佩奇的经营管理智慧" class="headerlink" title="拉里·佩奇的经营管理智慧"></a>拉里·佩奇的经营管理智慧</h4><p><em><strong>内容精采</strong></em></p><ul><li>所谓好的品牌产品，首先要功能好，其次要让大家认可相应的品牌；</li><li>把产品做成牙刷，需要解决两个根本性问题：第一，可靠性和稳定性；第二，由于容易被同类产品替代，所以要出爆款；（英特尔的X86每18个月推出性能之前2倍的处理器，及时刷新大家的记忆）</li><li>从本质中寻找商业模式，将有用的信息送达每一个用户；（有用的内容并不需要是自己的；谷歌控制搜索的结果对用户是有用的，即使收取广告费，也不影响自然搜索结果）</li><li>在公司方兴未艾的时候，就开始考虑公司将来衰老死亡的问题；</li></ul><h4 id="巴菲特午餐：人生的智慧"><a href="#巴菲特午餐：人生的智慧" class="headerlink" title="巴菲特午餐：人生的智慧"></a>巴菲特午餐：人生的智慧</h4><p><em><strong>内容精采</strong></em></p><ul><li>巴菲特说：”年轻人，我不用告诉你们该做什么，因为你们很优秀，你们自己知道该做什么。我告诉你们一生不该做什么。第一，不要做自己不懂的事情；第二，永远不要做空股票；第三，永远不要用杠杆投资；”</li><li><strong>人一生不要二次富有，少犯错误比多几次成功更重要；</strong> 从结果上来看可能钱并不少，但是他的家庭生活、他家人的生活、他的心态，都可能变得非常不健康、不愉快；</li><li>巴菲特看中的确实IBM和英特尔这样的公司，虽然成长不如谷歌、脸谱网或者亚马逊快，却能产生文档的现金流。巴菲特总是寻找”现金奶牛”，然后每年收获大量的现金，再拿那些现金去购买更多的”现金奶牛”股票，以实现公司价值的复合增长；</li></ul><h4 id="司马迁的智慧：东方最早的经济学综合论文《货殖列传》"><a href="#司马迁的智慧：东方最早的经济学综合论文《货殖列传》" class="headerlink" title="司马迁的智慧：东方最早的经济学综合论文《货殖列传》"></a>司马迁的智慧：东方最早的经济学综合论文《货殖列传》</h4><p><em><strong>内容精采</strong></em></p><ul><li>“故善者因之，其次利道之，其次教诲之，其次整齐之，最下者与之争。”（统治者想完成某件事，好的就随国民去了，差点的用利益引导，再差点试图教化，再差点约束管理，最差和国民作对）</li><li>“天下熙熙，皆为利来；天下攘攘，皆为利往”。换今天的话说，大家天天这么忙，就是为了一个”利”字；</li><li>那些看似微小甚至卑贱的生意，比如农业、卖油、贩酒等，只要经营得好，做到极致，也能获得巨大的成功；再有钱的商人如果没有核心的业务，生意也是持久不了的，这说明核心业务的重要性；</li></ul><h4 id="销售大师的智慧（王晓峰）"><a href="#销售大师的智慧（王晓峰）" class="headerlink" title="销售大师的智慧（王晓峰）"></a>销售大师的智慧（王晓峰）</h4><p><em><strong>内容精采</strong></em></p><ul><li>销售的本质，是把钱收回来，而不只是把东西卖出去；把钱收回来是目的，而把货卖出去只是手段，很多销售人员的做法实际上是背本趋末了；</li><li>美国人在定价时通常会留一个比例，比如5%作为收款的成本，你如果先付账，可以省去这个成本；</li><li>持续的生意：让顾客把买的东西用光；管理团队时，每一次升迁，都要将上一次的贡献清零；</li><li>如果我们能顾及别人的面子，生意就能做好，事情就能做好；如果我们<strong>为别人提供价值</strong>，而不是一味地推销，我们的产品，甚至我们自己，就会受到欢迎；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第二章-人生需要做减法&quot;&gt;&lt;a href=&quot;#第二章-人生需要做减法&quot; class=&quot;headerlink&quot; title=&quot;第二章 人生需要做减法&quot;&gt;&lt;/a&gt;第二章 人生需要做减法&lt;/h3&gt;&lt;h4 id=&quot;西瓜与芝麻&quot;&gt;&lt;a href=&quot;#西瓜与芝麻&quot; class</summary>
      
    
    
    
    
    <category term="除了工作以外的" scheme="http://joruachan.cn/tags/%E9%99%A4%E4%BA%86%E5%B7%A5%E4%BD%9C%E4%BB%A5%E5%A4%96%E7%9A%84/"/>
    
    <category term="《见识》" scheme="http://joruachan.cn/tags/%E3%80%8A%E8%A7%81%E8%AF%86%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Netty日记</title>
    <link href="http://joruachan.cn/2021-11-07/netty-daily/"/>
    <id>http://joruachan.cn/2021-11-07/netty-daily/</id>
    <published>2021-11-06T16:00:00.000Z</published>
    <updated>2022-08-17T16:05:57.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2021年11月6日"><a href="#2021年11月6日" class="headerlink" title="2021年11月6日"></a>2021年11月6日</h2><h3 id="Linux-I-O"><a href="#Linux-I-O" class="headerlink" title="Linux I/O"></a>Linux I/O</h3><ol><li>只有内核能与外设交互，且内核将外设的操作都视作文件操作；对文件的操作，内核都会返回fd文件描述符；对socket的读写也有对应的socket fd；</li><li>五种IO模型：阻塞IO、非阻塞IO、IO复用、信号驱动、异步IO；</li></ol><p>五种IO模型总结：</p><ol><li>所有IO操作，都包含：内核等待数据准备好、内核拷贝数据到用户空间；</li><li>除了异步IO，其他四种模型在拷贝期间，进程都是阻塞的；</li><li>阻塞IO：两步期间，进程阻塞直到拷贝完成，期间进程不能做其他事；</li><li>非阻塞IO：数据准备好前，会主动轮询内核是否准备好数据了，进程虽然未阻塞，但是也干不了其他事情；拷贝期间进程阻塞；</li><li>IO复用：复用的意义在于，将多个IO请求汇总到一个select阻塞请求上，而不需要每个进程都阻塞；select请求会阻塞遍历所有事件，直至找到完成的事件；可以理解成通过多个进程间的协作完成IO；</li><li>信号驱动：当数据准备好的时候，内核向用户进程发送SIGIO信号通知；拷贝期间会阻塞；</li><li>异步IO：用户进程全程无需关心，发起请求后，内核开始等待数据准备好，将数据从内核拷贝到用户空间后，向用户进程递交信号；</li></ol><h2 id="2021年11月7日"><a href="#2021年11月7日" class="headerlink" title="2021年11月7日"></a>2021年11月7日</h2><h3 id="Linux对IO复用的支持"><a href="#Linux对IO复用的支持" class="headerlink" title="Linux对IO复用的支持"></a>Linux对IO复用的支持</h3><ol><li>支持IO复用的函数调用：select、pselect、poll、epoll;</li><li>select：通过轮询fd, 来查看IO是否就绪；缺点：单个进程下只支持1024个fd，需要轮询所有的fd；</li><li>epoll：select的替代方案；优点：<ul><li>无fd限制，支持OS的最大文件句柄数；</li><li>只对注册的、活跃的fd遍历查看是否就绪；</li><li>fd就绪的消息通知使用mmap内存共享，减少内核拷贝到用户空间的开销；</li></ul></li></ol><h2 id="2021年11月15日"><a href="#2021年11月15日" class="headerlink" title="2021年11月15日"></a>2021年11月15日</h2><h3 id="IO编程范式"><a href="#IO编程范式" class="headerlink" title="IO编程范式"></a>IO编程范式</h3><p>回味下在C/S模式下，网络IO编程的常用规范；</p><h4 id="传统BIO"><a href="#传统BIO" class="headerlink" title="传统BIO"></a>传统BIO</h4><p>一个客户端的请求，要创建一个线程处理；Acceptor接收到client的请求后，创建一个线程，并将socket对象传递进行链接建立、处理请求并返回；</p><ul><li>弊端：服务器资源有限，只能支持并发量很低的场景；</li></ul><h4 id="伪异步IO"><a href="#伪异步IO" class="headerlink" title="伪异步IO"></a>伪异步IO</h4><p>利用线程池技术，使得请求和线程的关系为M:N，通过线程池灵活调整线程资源，防止线程耗尽；Acceptor接收到client的请求后，从线程池中取出一个可用线程，并将socket对象传递进行链接建立、处理请求并返回；</p><ul><li>弊端：能避免线程耗尽，但是BIO的read和write方法都是阻塞的；当逻辑复杂的时候，处理时间较久，容易导致其他的线程排队阻塞；整体看，处理速度由IO速度、网络传输速度绝对，而处理速度直接决定了在高并发情况下的响应速度；所以，该方案支持一定并发量的请求，但是不能支持高并发；</li></ul><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>Java NIO主要由Buffer缓冲池、Channel通道、Selector多路复用器组成；将Channel关心的事件注册到Selector上；Channel上有事件时，Channel会就绪，Selector就能轮询出就绪的Channel事件；Channel上数据的读写都通过Buffer对象处理；</p><ul><li>弊端：Java NIO基于epoll实现了IO多路复用，支持成千上万的并发量，但是代码量大、编程方式较复杂；</li></ul><h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><p>Java NIO提供了异步文件通道和异步套接字通道，可以实现真正的异步IO；通过CompletionHandler实现IO结束时的回调；</p><h2 id="2021年11月30日"><a href="#2021年11月30日" class="headerlink" title="2021年11月30日"></a>2021年11月30日</h2><p>获取时间的C/S，通过不同IO编程范式的代码实现案例，<a href="https://github.com/JoruaChan/All-In-Java/tree/master/java-io">点击跳转</a>；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2021年11月6日&quot;&gt;&lt;a href=&quot;#2021年11月6日&quot; class=&quot;headerlink&quot; title=&quot;2021年11月6日&quot;&gt;&lt;/a&gt;2021年11月6日&lt;/h2&gt;&lt;h3 id=&quot;Linux-I-O&quot;&gt;&lt;a href=&quot;#Linux-I-O&quot; c</summary>
      
    
    
    
    
    <category term="Java面试复习" scheme="http://joruachan.cn/tags/Java%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="Netty" scheme="http://joruachan.cn/tags/Netty/"/>
    
    <category term="高并发" scheme="http://joruachan.cn/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>tcpdump初体验</title>
    <link href="http://joruachan.cn/2021-11-02/tcpdump-essay/"/>
    <id>http://joruachan.cn/2021-11-02/tcpdump-essay/</id>
    <published>2021-11-01T16:00:00.000Z</published>
    <updated>2022-08-17T16:05:57.206Z</updated>
    
    <content type="html"><![CDATA[<ol><li>tcpdump命令抓取包</li><li>使用下载安装好的Wireshark软件打开</li><li>分析过滤你需要的包</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;tcpdump命令抓取包&lt;/li&gt;
&lt;li&gt;使用下载安装好的Wireshark软件打开&lt;/li&gt;
&lt;li&gt;分析过滤你需要的包&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    <category term="随笔" scheme="http://joruachan.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="计算机网络" scheme="http://joruachan.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="抓包" scheme="http://joruachan.cn/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>透彻理解RTP</title>
    <link href="http://joruachan.cn/2021-10-22/rtp-introduction/"/>
    <id>http://joruachan.cn/2021-10-22/rtp-introduction/</id>
    <published>2021-10-21T16:00:00.000Z</published>
    <updated>2022-08-17T16:06:04.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RTP——实时传输协议"><a href="#RTP——实时传输协议" class="headerlink" title="RTP——实时传输协议"></a>RTP——实时传输协议</h2><p>RTP（Real-time Transport Protocol），实时传输协议；RTP协议在<a href="https://datatracker.ietf.org/doc/html/rfc3550">RFC 3550</a>文档中详细说明了在互联网上传递音频和视频的标准数据包格式。</p><p>它一开始被设计为一个多播协议，但后来被用在很多的单播应用中。RTP协议常用于流媒体系统、视频会议，使它成为IP电话产业的技术基础。</p><p>RTP协议通常是建立在UDP协议之上的，由于UDP面向数据报，是非可靠的，所以如果需要提高服务质量，则需要实现RTCP协议；通常RTP和RTCP是相邻的两个端口，偶数端口是RTP通信，偶数+1的奇数端口是RTCP通信；</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>多播音频会议，通过一个多播地址和一对端口（一个传输RTP，一个传输RTCP）来实现；</li><li>音视频会议，利用两个RTP会话传输，一个传视频数据，一个传音频数据。每个会话对应的RTCP都有CNAME，根据CNAME获取对应的音视频，并根据计时信息实现音视频同步；</li><li>翻译器，RTP级的中继系统。翻译器用在通过IP多播不能直接到达的用户区，例如发送者和接收者之间存在防火墙；</li><li>混合器，RTP级的中继系统。当与会者能接收的音频编码格式不一样，比如有一个与会者通过一条低速链路接入到高速会议，这时就要使用混合器。在进入音频数据格式需要变化的网络前，混合器将来自一个源或多个源的音频包进行重构，并把重构后的多个音频合并，采用另一种音频编码进行编码后，再转发这个新的RTP包。从一个混合器出来的所有数据包要用混合器作为它们的SSRC（同步源）来识别，可以通过CSRC表（贡献源列表）确认谈话者；</li></ol><h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><h3 id="传输层的子层"><a href="#传输层的子层" class="headerlink" title="传输层的子层"></a>传输层的子层</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/rtp-introduction/rtp-layer.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/rtp-introduction/rtp-layer.png" srcset="data:image/png;base64,666" alt="图片源自网络"/></div><span class="image-caption">图片源自网络</span></div><p>由上图可以看出，RTP被划分在传输层，它建立在UDP上。同UDP协议一样，为了实现其实时传输功能，RTP也有固定的封装形式。</p><h3 id="开发者的”应用层”"><a href="#开发者的”应用层”" class="headerlink" title="开发者的”应用层”"></a>开发者的”应用层”</h3><p>对于开发者来说，RTP如同应用层，因为<strong><em>RTP的实现需要开发者自行完成</em></strong>；</p><h2 id="会话过程"><a href="#会话过程" class="headerlink" title="会话过程"></a>会话过程</h2><h3 id="确认好传输地址"><a href="#确认好传输地址" class="headerlink" title="确认好传输地址"></a>确认好传输地址</h3><p>当应用程序建立一个RTP会话时，应用程序将确定一对目的传输地址。目的传输地址由一个网络地址和一对端口组成，有两个端口：一个给RTP包，一个给RTCP包，使得RTP/RTCP数据能够正确发送。RTP数据发向偶数的UDP端口，而对应的控制信号RTCP数据发向相邻的奇数UDP端口（偶数的UDP端口＋1），这样就构成一个UDP端口对。</p><h3 id="发送过程（接收过程相反）"><a href="#发送过程（接收过程相反）" class="headerlink" title="发送过程（接收过程相反）"></a>发送过程（接收过程相反）</h3><ol><li>接收如麦克风、摄像头等设备处理后，得到音视频编码后的流媒体信息码流（如H.263），封装成RTP数据包；RTCP从上层接收控制信息，封装成RTCP控制包;</li><li>将RTP数据包发往UDP端口对中偶数端口；RTCP将RTCP控制包发往UDP端口对中的接收端口;</li></ol><h2 id="数字音频信号处理"><a href="#数字音频信号处理" class="headerlink" title="数字音频信号处理"></a>数字音频信号处理</h2><p>数字音频处理的大方向是把我们所听到的声音以数字的方式记录下来，让计算机进行处理；</p><h3 id="声音的产生和传播"><a href="#声音的产生和传播" class="headerlink" title="声音的产生和传播"></a>声音的产生和传播</h3><p>声音是通过震动产生的，震动迫使着空气震动，声音在空气中以波的形式传播，空气震动迫使你的耳骨膜震动，从而听到声音。</p><h3 id="声音的记录"><a href="#声音的记录" class="headerlink" title="声音的记录"></a>声音的记录</h3><p>震动耳骨膜能让人听到声音，那么用某个物体来模仿我们的耳骨膜来接收声音。例如：留声机中的振片就相当于人类的耳骨膜。</p><h3 id="模拟信号-amp-数字信号"><a href="#模拟信号-amp-数字信号" class="headerlink" title="模拟信号&amp;数字信号"></a>模拟信号&amp;数字信号</h3><p>声音的模拟信号是一段连续变化的波形；数字信号是将连续变化的波形转换成离散的数字信号；例如：振片接收的声音通过AD变换器转变为数字信号。</p><h3 id="模拟信号转数字信号"><a href="#模拟信号转数字信号" class="headerlink" title="模拟信号转数字信号"></a>模拟信号转数字信号</h3><p>模拟信号到数字信号分为3步：采样，量化，编码；</p><ul><li>采样：声音的模拟信号是一段连续的波形，数字信号是对波形采集样本得到的，一个点表示一个样本，采样所取得的数值是**<em>音频的模拟电压值**</em>；</li><li>量化：把电压值按照位数分级，每一区间统一为一个数值。<strong><em>用近似值来表示采样点的电压值</em></strong>，分级越多，数字音频质量就越高。通常电话语音用8位（256级）或CD用16位（65536级）；</li><li>编码：将模拟信号的量化值用二进制的方式进行编码；</li></ul><h2 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h2><p>脉冲编码调制，按照固定频率采样将声音从模拟信号转成数字信号，是 <strong><em>未经压缩的采样数据裸流</em></strong> ；该数据没有文件头和尾；WAV格式就是在PCM文件前面加了一个长44字节的文件头；</p><h3 id="两个重要指标"><a href="#两个重要指标" class="headerlink" title="两个重要指标"></a>两个重要指标</h3><ul><li>采样频率：数字信号对模拟信号的波形进行采样还原的频率，一定时间内采样频率越高，还原精度越高；（采样定理：用大于信号最高频率两倍的频率，对周期信号进行采样，可以保证完全重构原始信号）</li><li>量化精度：采样到的电压值会对该值量化成一个近似值；如果采取均匀量化，会导致信号失真，也就是弱信号恢复的差；所以，<em><strong>一般采用非均匀量化（弱信号密度大）或者提高量化精度；</strong></em></li></ul><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>将量化得到的二进制数据进行压缩，即编码数据；一般采用的是样本内压缩，如将16it的样本数据压缩成8bit的PCM样本数据；主要用的压缩算法是a-law和mu-law；</p><h3 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h3><p>编码好的数据调制了才能播放，调制器会根据下节介绍的相关信息进行调制播放；</p><h2 id="计量单位和换算"><a href="#计量单位和换算" class="headerlink" title="计量单位和换算"></a>计量单位和换算</h2><ul><li>声道数：单/立体；</li><li>样本位数：一个样本的二进制位数；4/8/16/32bit;</li><li>采样频率: 一秒钟采样的次数，8kHz/11.025kHz/22.05kHz/16kHz/37.8kHz/44.1kHz/48kHz；</li><li>比特率： 样本位数 * 采样频率 * 声道数</li><li>帧率：FPS，帧/秒，每秒钟刷新的帧数；</li></ul><blockquote><p>Q：已知采样率16k，采样位宽16bit，单声道；求每帧的播放时间？每帧的数据大小？<br>A: 帧率50，则每帧播放时间：1s/50=20ms；再以每帧的时间20ms将1s等分50份，可得到每帧的样本数量：16000/50=320个；发送方压缩后每帧的数据大小：320*8bit=320byte；接收方解码后每帧640byte；</p></blockquote><h2 id="RTP数据包"><a href="#RTP数据包" class="headerlink" title="RTP数据包"></a>RTP数据包</h2><h3 id="RTP数据包组成"><a href="#RTP数据包组成" class="headerlink" title="RTP数据包组成"></a>RTP数据包组成</h3><p>RTP数据包 = UDP头部（8字节）+ RTP头部（标准12字节）+ Payload数据</p><h3 id="RTP包最大长度"><a href="#RTP包最大长度" class="headerlink" title="RTP包最大长度"></a>RTP包最大长度</h3><blockquote><p>MTU：链路层限制了数据帧的最大长度，以太网和802.3分别规定为1500字节和1492字节；</p></blockquote><p>在TCP/IP层，需要依据MTU对数据报进行分片，保证每片的长度小于MTU；由此可知：<br>TCP：1500 - 20（ip头）- 20（tcp头）- 4（RTP标志）= 1456<br>UDP：1500 - 14（以太网头）- 20 (ip头）- 8 (udp头） = 1458</p><p>所以，<strong>一个RTP数据包最多承载 1458 - 12 = 1446 字节长的有效负载</strong>。将payload数据放入MTU为1500字节的网络上，标准的12字节长的RTP头部数据包(1458 字节)中。<br>在实践中，如果通过Internet传输这些流量，这些流量会被封装或跨不同的传输层传输，<strong>一般保持payload负载长度在 1400 字节以下以确保安全</strong>。</p><h3 id="包的头部组成"><a href="#包的头部组成" class="headerlink" title="包的头部组成"></a>包的头部组成</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/rtp-introduction/rtp-header.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/rtp-introduction/rtp-header.png" srcset="data:image/png;base64,666" alt="图片源自网络"/></div><span class="image-caption">图片源自网络</span></div><ul><li>版本号（V）：2比特，用来标志使用的RTP版本；</li><li>填充位（P）：1比特，如果该位置位的话，RTP包的尾部就包含附加的填充字节；</li><li>扩展位（X）：1比特，如果该位置位的话，RTP固定头部后面就跟有一个扩展头部；</li><li>CSRC计数器（CC）：4比特，含有固定头部后面跟着的CSRC的数目；</li><li>标记位（M）：1比特，该位的解释由配置文档（Profile）来承担；</li><li>载荷类型（PT）：7比特，标识了RTP载荷的类型，接收端用合适的解码器去解码并播放；</li><li>序列号（SN）：16比特，发送方在每发送完一个RTP包后就将该域的值增加1，接收方可以由该域检测包的丢失及恢复包序列，序列号的初始值是随机的；</li><li>时间戳：32比特，记录了该包中数据的第一个字节的采样时刻。在一次会话开始时，时间戳初始化成一个初始值。即使在没有信号发送时，时间戳的数值也要随时间而不断地增加（时间在流逝嘛）。时间戳是去除抖动和实现同步不可缺少的；</li><li>同步源标识符(SSRC)：32比特，同步源就是指RTP包流的来源，在同一个RTP会话中不能有两个相同的SSRC值，该标识符是随机选取的RFC1889推荐了MD5随机算法；</li><li>贡献源列表（CSRC List）：0～15项，每项32比特，用来标志对一个RTP混合器产生的新包有贡献的所有RTP包的源。由混合器将这些有贡献的SSRC标识符插入表中。SSRC标识符都被列出来，以便接收端能正确指出交谈双方的身份。</li></ul><p>整理时间有限，还未整理完全，后续补充跟进~~~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RTP——实时传输协议&quot;&gt;&lt;a href=&quot;#RTP——实时传输协议&quot; class=&quot;headerlink&quot; title=&quot;RTP——实时传输协议&quot;&gt;&lt;/a&gt;RTP——实时传输协议&lt;/h2&gt;&lt;p&gt;RTP（Real-time Transport Protocol），</summary>
      
    
    
    
    
    <category term="RTP" scheme="http://joruachan.cn/tags/RTP/"/>
    
    <category term="网络协议" scheme="http://joruachan.cn/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="计算机网络" scheme="http://joruachan.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>再回首JDK</title>
    <link href="http://joruachan.cn/2021-09-23/look-back-jdk/"/>
    <id>http://joruachan.cn/2021-09-23/look-back-jdk/</id>
    <published>2021-09-22T16:00:00.000Z</published>
    <updated>2022-08-17T16:06:04.074Z</updated>
    
    <content type="html"><![CDATA[<p>如果你是刚要被Java军训的新兵，可有几时对环境搭建而不知所措？又如若你是驰骋Java战场多年的老将，可曾拿起陪伴你许久的82年的JDK回味一番？今天我们就来道一道JDK，重新来认识认识这个既熟悉又陌生的伙伴。</p><p>既然要唠唠JDK，首先想到的，肯定是要了解下都是谁来推进Java和JDK发展的。</p><h2 id="Java发展的会议与组织"><a href="#Java发展的会议与组织" class="headerlink" title="Java发展的会议与组织"></a>Java发展的会议与组织</h2><p>说起Java的起源必定要提起Sun公司，由其发起了专属于Java的JavaOne会议。不过Sun公司被Oracle收购后，JavaOne会议同Oracle先前的Oracle OpenWorld会议并成了<a href="https://www.oracle.com/code-one/">Oracle Code One会议</a>，并且会议内容也不再单纯讨论Java的发展。另外还有JCP（Java Community Process）是个开放性的国际技术标准组织，职责是发展和更新Java 技术规范，由其推出了大量Java相关技术规范JSR，具体可<a href="https://jcp.org/en/home/index">点此查看</a>。JCP的运作方式是由个人或者厂商提出JSR规范提案，再有JCP委员会的成员投票表决是否采用。其弊端是JCP委员会还是主要由厂商组成，这些规范可能更偏向于厂商的利益，而非大众的利益。</p><h2 id="JDK版本"><a href="#JDK版本" class="headerlink" title="JDK版本"></a>JDK版本</h2><p>我们要知道Java应用开发并不是只有常接触的移动端 、服务端的应用开发。Sun公司根据不同业务领域方向分成了四个JDK版本：</p><ul><li>Java Card，主要是以具有安全防护性的方式来执行小型的Java Applet，广泛运用在SIM卡、提款卡上；</li><li>Java SE，前称J2SE。Java的标准版，为JavaEE和JavaME提供了基础类库以及能力。也是我们安装部署Java环境最基础的版本；</li><li>Java EE，前称J2EE。针对企业级应用的加强版。主要涉及的技术：JDBC、EJB（被Spring遮住了光芒）、Servlet、RMI、JNDI、JMS、JPA、JTS等。Java 10版本以后被Oracle公司放弃，捐献给了Eclipse基金会，并后成为Jakarta EE;</li><li>Java ME，前称J2ME。主要用于移动设备、嵌入式设备上的java应用程序；</li></ul><h2 id="Oracle-JDK-vs-Open-JDK"><a href="#Oracle-JDK-vs-Open-JDK" class="headerlink" title="Oracle JDK vs Open JDK"></a>Oracle JDK vs Open JDK</h2><p>Open JDK现已作为Java版本迭代的发展标准，并且开源。而Oracle JDK只不过是Open JDK的具体实现，不完全对外开源。</p><p>至于它俩的区别，下面的列表基本列出：</p><table><thead><tr><th></th><th>Oracle JDK</th><th>Open JDK</th></tr></thead><tbody><tr><td>起源时间</td><td>JDK1.0，1996年1月发行</td><td>OpenJDK 6（基于Java SE 7），2007年发行</td></tr><tr><td>代码协议</td><td>新的OTN协议，2019年1月之后发布的Oracle JDK 8更新将无法用于商业</td><td>GPLv2+CE</td></tr><tr><td>发行周期</td><td>JDK6及之前大约每两年一版本，6至7五年，7至8、8至9三年;JDK10及以后均6个月一个大版本；每3年一个LTS版本；</td><td>OpenJDK 9及之前大约三年一个版本；OpenJDK 10及以后均6个月一个大版本；</td></tr><tr><td>支持时间</td><td>从JDK10起，每6个月一个大版本；从JDK11起，每3年一个LTS长期维护的版本；</td><td>从JDK10起，每6个月一个大版本；不发行LTS版本，只维护半年，也就是下个版本发布便不再维护。但是有其他顶级公司继续维护，如Red Hat OpenJDK，Liberica OpenJDK</td></tr><tr><td>商标</td><td>java商标拥有者</td><td>不可使用java</td></tr><tr><td>性能</td><td>响应能力、JVM性能更强，更稳定</td><td>——</td></tr><tr><td>功能</td><td>Flight Recorder，Java Mission Control和Application Class-Data Sharing</td><td>Font Renderer，但OpenJDK 11后也包含Oracle JDK的功能，还有ZGC; OpenJDK也会附带JMC开源，当前还在开发中</td></tr></tbody></table><p>如果你们公司既想应用新特性，又没有授权的话，那就使用OpenJDK 11吧！毕竟Oracle的产品总监也说了，Oracle JDK是基于OpenJDK源代码构建的，OracleJDK和OpenJDK在Java 11后，功能基本保持一致。可见链接：<a href="https://blogs.oracle.com/java-platform-group/oracle-jdk-releases-for-java-11-and-later">Oracle JDK Releases for Java 11 and Later</a>。</p><h2 id="各版本特性及重要事件"><a href="#各版本特性及重要事件" class="headerlink" title="各版本特性及重要事件"></a>各版本特性及重要事件</h2><div class="timeline"><div class="timenode"><div class="meta"><p><p>JDK 1.0</p></p></div><div class="body"><p>JDK 1.0在1996年1月23日发布，Java语言有了第一个正式版本的运行环境；</p></div></div><div class="timenode"><div class="meta"><p><p>JDK 1.2</p></p></div><div class="body"><p>JDK 1.2，Sun公司正式将Java拆分成J2SE，J2EE和J2ME三大技术体系；</p></div></div><div class="timenode"><div class="meta"><p><p>JDK 1.6</p></p></div><div class="body"><p>JDK 1.6，终结了J2EE、J2SE、J2ME的命名方式，启用Java SE 6、JavaEE 6、Java ME 6的命名方式。与此同时，Sun公司宣布将对Java技术开源；</p></div></div><div class="timenode"><div class="meta"><p><p>JDK 7</p></p></div><div class="body"><p>JDK 7，Sun公司被Oracle公司收购，发布时间延期；</p></div></div><div class="timenode"><div class="meta"><p><p>JDK 8</p></p></div><div class="body"><p>JDK 8，Oracle启用JEP（JDK Enhancement  Proposal）定义管理新版JDK发布的新特性，完成了JDK 7规划了但没有实现的功能，HotSpot移除掉永久代，吸收了JRockit的Java Mission Control监控工具等功能；8u201/202版本后，如果是用作商业用途，需要收费；</p></div></div><div class="timenode"><div class="meta"><p><p>JDK 9</p></p></div><div class="body"><p>JDK 9，jigsaw模块化、增强jshell、jlink、jhsdb等工具，并支持了91个JEP；此前均以特性驱动发行版本。9开始变成以时间驱动，发布周期为6个月一个大版本，3年一个 LTS版本；</p></div></div><div class="timenode"><div class="meta"><p><p>JDK 10</p></p></div><div class="body"><p>JDK 10，主要是JDK内部重构，只支持了12个JEP；Oracle公司抛弃Java EE，捐献给Eclipse基金会；</p></div></div><div class="timenode"><div class="meta"><p><p>JDK 11</p></p></div><div class="body"><p>JDK 11，推出了ZGC垃圾收集器（只支持64位的Linux机器），支持了17个JEP；第一个官宣的LTS发行版；</p></div></div><div class="timenode"><div class="meta"><p><p>JDK 12</p></p></div><div class="body"><p>JDK 12：推出非Oracle开发的Shen-andoah垃圾收集器，OracleJDK随后剔除了，存在于OpenJDK，支持了8个JEP；</p></div></div><div class="timenode"><div class="meta"><p><p>JDK 13</p></p></div><div class="body"><p>JDK 13：支持5个JEP；</p></div></div><div class="timenode"><div class="meta"><p><p>JDK 14</p></p></div><div class="body"><p>JDK 14：推出Windows和MacOS的ZGC垃圾收集器，支持16个JEP；</p></div></div><div class="timenode"><div class="meta"><p><p>. . . . . .</p></p></div><div class="body"></div></div></div><p>各版本具体的New Feature，大家可以直接上Oracle官网追溯。或者查看我推荐的两篇博文：<a href="https://blog.csdn.net/qq934235475/article/details/82220076">博文1传送门</a>、<a href="https://blog.csdn.net/lzw2497727771/article/details/104019737">博文2传送门</a>。我这里就不再赘述了，后面会开个专栏，去探索实践Java每个版本特性的实现。</p><h2 id="解密JDK包"><a href="#解密JDK包" class="headerlink" title="解密JDK包"></a>解密JDK包</h2><p>JDK的运用，渗透到从事Java开发工作的各位的每一天，从开发到调试，再到发布和部署，以及上线后的运维都息息相关。相信在座的各位，一定有过疑问，jdk到底是怎么组成的？了解这些可能对我们的开发工作没有太多的作用，但是哪位又能预料明天和bug哪个先到呢，也许这就是你找到问题根因的地方！再不济，学习点知识，总不会有坏处！跟随我的脚步，一起看看JDK到底是怎么构成的吧！</p><h3 id="组成架构"><a href="#组成架构" class="headerlink" title="组成架构"></a>组成架构</h3><p>我们先来看下官方文档中Java SE版本JDK的组成架构图：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/look-back-jdk/jdk-composition.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/look-back-jdk/jdk-composition.png" srcset="data:image/png;base64,666"/></div></div><p>很直接地可以看出，最下面的Java HotSpot VM，是Java运行最基础的组件；Java SE API即我们日常编程使用的Java类库；JRE是Java应用程序运行的最小环境，其中包括了JVM，Java SE API类库和其他标准或非标准组件；JDK包含了JRE和一些Tool。Java8增加新特性Compact Profiles，是因为Java丰富的类库在小型应用中显得有些累赘，便将JRE分成了三种实现，compact1、compact2和compact3，具体的拆分情况如下，可见数字越大，包含的内容越多。在编译时，使用<kbd>option: -profile</kbd>，指定对应的实现方式即可。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/look-back-jdk/compact-profiles.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/look-back-jdk/compact-profiles.png" srcset="data:image/png;base64,666"/></div></div><h3 id="JDK文件组成"><a href="#JDK文件组成" class="headerlink" title="JDK文件组成"></a>JDK文件组成</h3><p>以windows环境的Java 8u261版本为例，针对JDK的组成架构进行解读。先来了解下解压或者安装完JDK的文件夹结构吧：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/look-back-jdk/jdk-dir.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/look-back-jdk/jdk-dir.png" srcset="data:image/png;base64,666"/></div></div><ul><li>bin目录中存放了开发过程的编译解释工具，如java.exe、javac.exe等，以及开发运维工作中常用的资源消耗统计等不同功能的辅助工具，如jmap.exe、jconsole.exe、jstat.exe等。</li><li>include目录下可以看到都是以.h结尾的文件，用来支持Java中用到的本地方法以及JVM调试程序接口用到的本地技术。</li><li>jre目录则是jdk运行的开发环境时使用的runtime，如jdk bin目录下的执行文件都是建立在这个jre文件夹的基础上 ！当然也是可以单纯用于Java编写的程序。需要说明的，如果存在期望依赖的jar包（如中间件的驱动程序），可以放置于jre的lib目录下的ext文件夹 。</li><li>lib目录是存放JDK bin目录下可执行文件依赖的jar包等，如常见的tools.jar；</li><li>src.zip则是Java类库源码，主要包含rt.jar，以及程序启动器Launcher源码，主要功能是创建ExtClassLoader和AppClassLoader，根据配置创建SercurityManager，设置进程上下文类加载器；</li></ul><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>Oracle官网po出组成架构图最下面便是最基础、最重要的JVM技术，是在真实计算机上模拟虚拟的计算机功能。正是它的存在，才成就了“一次编译，多次运行”；</p><p>Java8后提供了两种模式的VM，一种是Client，通常用于客户端应用程序，可以减少应用的启动时间和内存占用，一种是Server，会提升运行时执行速度；在jvm.cfg文件中第一个是默认实现，默认是-server KNOWN，KNOWN可设置成IGNORE，这只是表示相应的option是否启用。</p><p>此处列出两个Q&amp;A，这也是我最初接触JVM的疑问。</p><p><strong><em>Q1：JVM作为Java程序最重要的组件，为什么文件夹里没有一个很明显的文件表示用于JVM的呢？</em></strong></p><p>A1：JVM以动态库的形式存在，Windows上置于jre的bin文件夹下的server或者client文件夹里的jvm.dll。Linux上置于jre的lib文件下的/amd**/server或者/amd**/client文件夹下的libjvm.so。</p><p><strong><em>Q2：JVM是怎么被加载并实例化的？</em></strong></p><p>A2：JVM加载是通过java.exe来完成：首先通过launcher下的main函数创建JVM装载环境、配置，然后装载jvm.dll，装载完成后通过JNI本地调用接口找到JNI_CreateJavaVM的函数地址，然后调用函数去实例化JNIEnv对象：JVM，最后便通过JVM实例装载并处理class文件。代码调用顺序如下，童鞋可自行看下源码：main() &gt; JLI_Launch() &gt; CreateExecutionEnvironment() &gt; SetJvmEnvironment() &gt; LoadJavaVM() &gt; JVMInit() &gt; JavaMain() &gt; InitializeJVM() &gt; CreateJavaVM() [调用JNI接口] &gt; LoadMainClass() &gt; GetApplicationClass() ；</p><p>哦~~原来是这样啊！是不是对JVM进一步认识了呢？不过这才是皮毛，剩下的等我开个专题慢慢道来！还不赶紧关注我？</p><h3 id="JRE-依赖包"><a href="#JRE-依赖包" class="headerlink" title="JRE 依赖包"></a>JRE 依赖包</h3><p>JRE运行所依赖的jar包，包含在/jre/lib和/jre/lib/ext文件夹下，如果有jar包希望作为JVM信任的Jar包第一时间加载，也可以直接将jar包置于/jre/lib/ext文件夹下。介绍下所有依赖的jar包：</p><table><thead><tr><th>jar包</th><th>作用</th></tr></thead><tbody><tr><td>access-bridge.jar</td><td>Microsoft Windows操作系统的Java Access Bridge使基于Windows的辅助技术可以与Java Accessibility API进行交互；</td></tr><tr><td>charsets.jar</td><td>扩展的字符集。rt.jar中sun.nio.cs包下为基础的字符集；</td></tr><tr><td>cldrdata.jar</td><td>数据标准库，用于数据的国际化和本地化。可见：<a href="http://cldr.unicode.org/">cldr官网</a>；</td></tr><tr><td>deploy.jar</td><td>用于部署应用的执行安装程序；</td></tr><tr><td>dnsns.jar</td><td>处理DNS服务，暴露lookupAllHostAddr(),getHostByAddr()方法，用于InetAddress；</td></tr><tr><td>jaccess.jar</td><td>Java Accessibility Utilities实用程序类的一部分，可帮助辅助技术提供对实现Java Accessibility API的GUI工具包的访问；</td></tr><tr><td>javaws.jar</td><td>JNLP协议，支持Java Web Start应用，可以直接通过浏览器执行Java应用程序；</td></tr><tr><td>jce.jar</td><td>扩展的加密包；</td></tr><tr><td>jfr.jar</td><td>Java飞行记录器，是JMC的一个重要组成部分，用于记录JVM和运行的Java程序的诊断数据、分析数据。对性能影响小于1%；</td></tr><tr><td>jfxrt.jar</td><td>JavaFX的运行时核心jar包，相当于rt.jar</td></tr><tr><td>jfxswt.jar</td><td>为JavaFX和Swing提供兼容性操作</td></tr><tr><td>jsse.jar</td><td>用于验证SSL连接的jar</td></tr><tr><td>localedata.jar</td><td>国际化的数据</td></tr><tr><td>management-agent.jar</td><td>只有MANIFEST.MF一个文件，用于VisualVM或者JConsole等工具的代理jar包；可<a href="https://www.cnblogs.com/huanshilang/p/12206644.html">查看实际应用介绍</a></td></tr><tr><td>nashorn.jar</td><td>Java嵌入式的JS引擎，可以实现js与Java的相互调用，还可以使用jrunscript命令运行js；</td></tr><tr><td>plugin.jar</td><td>用于各种使用场景的插件jar包</td></tr><tr><td>resources.jar</td><td>用于各种使用场景用到的静态资源，如.properites，.png，.css，.txt等文件</td></tr><tr><td><strong>rt.jar</strong></td><td>Java的runtime运行时核心代码包</td></tr><tr><td>sunec.jar,sunjce_provider.jar, sunmscapi.jar,sunpkcs11.jar</td><td>加密相关的jar包</td></tr><tr><td>zipfs.jar</td><td>支持对zip压缩包文件操作</td></tr></tbody></table><h3 id="rt-jar介绍"><a href="#rt-jar介绍" class="headerlink" title="rt.jar介绍"></a>rt.jar介绍</h3><p>Java SE版本涉及的基础核心类库，源码则可以将jdk的src.zip解压后查看。但是并非rt.jar中的所有包都是有源码的。</p><p>具体API都可以在<a href="https://docs.oracle.com/javase/8/docs/api/index.html">https://docs.oracle.com/javase/8/docs/api/index.html</a>查看，或者下到电脑自行查看，不同版本的API直接将”/8/“变更成你需要的Java版本即可。</p><p>接下来介绍下组成架构图中Java SE规范除去UI Toolkits的模块以及功能。</p><table><thead><tr><th>模块</th><th>API规范</th><th>功能</th></tr></thead><tbody><tr><td>lang and util</td><td>java.lang.* <br>java.util.*</td><td>提供几乎所有Java应用程序的基本功能</td></tr><tr><td>Math</td><td>java.lang.Math</td><td>java.lang.StrictMath<br>java.math</td></tr><tr><td>Management</td><td>java.lang.management<br>java.util.logging.LoggingMXBean<br>javax.management<br>com.sun.management<br>com.sun.tools.attach<br>com.sun.tools.jconsole</td><td>提供JVM、JConsole、JMX、日志等监控管理功能</td></tr><tr><td>Versioning</td><td>java.lang.Class<br>java.lang.ClassLoader<br>java.lang.Package<br>java.lang.System</td><td>提供Class、Package管理功能</td></tr><tr><td>Ref Objects</td><td>java.lang.ref</td><td>引用对象提供与GC有限交互功能</td></tr><tr><td>Reflection</td><td>java.lang.reflect</td><td>反射提供从JVM中查看加载类、修改对象的功能</td></tr><tr><td>Collections</td><td>基于java.util.Collection的实现<br>基于java.util.Map的实现</td><td>提供了功能强大、设计优秀的集合操作功能</td></tr><tr><td>Concurrency Utilities</td><td>java.utl.concurrent</td><td>提供了强大且易扩展的高并发解决方法</td></tr><tr><td>JAR</td><td>java.util.jar<br>java.net.JarURLConnection</td><td>提供了Jar文件的处理功能</td></tr><tr><td>Logging</td><td>java.util.logging</td><td>提供对日志记录的处理和交互</td></tr><tr><td>Preferences API</td><td>java.util.prefs</td><td>提供对用户和应用的首选项处理功能</td></tr><tr><td>Instrumentation</td><td>java.lang.instrument</td><td>用于工具来检测Java编程语言应用程序</td></tr><tr><td>Regular Expressions</td><td>java.util.regex</td><td>正则表达式</td></tr><tr><td>ZIP</td><td>java.util.zip</td><td>用于读取和写入标准ZIP和GZIP文件格式</td></tr><tr><td>Input/Output</td><td>java.io<br>java.nio<br>com.sun.nio</td><td>提供针对文件和设备I/O处理的丰富功能</td></tr><tr><td>Serialization</td><td>java.io</td><td>提供Java对象的序列化和反序列化功能</td></tr><tr><td>Networking</td><td>java.net<br>javax.net<br>com.sun.net<br>jdk.net等</td><td>提供用于网络处理的功能，<br>包括寻址、连接、安全等</td></tr><tr><td>Security</td><td>java.security<br>javax.crypto<br>javax.rmi.ssl<br>javax.xml.crypto<br>javax.smartcardio<br>com.sun.security<br>org.ietf.jgss等</td><td>用于与安全相关的功能的API，如访问控制，<br>数字签名，身份验证和授权，加密等</td></tr><tr><td>Internationalization</td><td>java.util.spi<br>java.util.Locale<br>java.text.DecimalFormatSymbols等</td><td>支持开发国际化应用程序的API，可以在不进行工程更改的情况下适应各种<br>语言和地区。</td></tr><tr><td>Beans</td><td>java.beans<br>java.beans.beancontext</td><td>主要提高了交互性和可维护性，JavaBeans的长期持久性可以读写bean作为<br>其属性值的文本表示形式</td></tr><tr><td>JMX</td><td>javax.management</td><td>Management Extension管理扩展，用于管理和<br>监控资源使用</td></tr><tr><td>XML JAXP</td><td>javax.xml<br>org.w3c.dom<br>org.xml.sax</td><td>用于处理XML文档和数据</td></tr><tr><td>JNI</td><td></td><td>用于编写Java本机方法并将Java虚拟机嵌入<br>本机应用程序的标准编程接口，<br>可以实现Java与其他语言的交互。<br>推荐一篇<a href="https://www.jianshu.com/p/6cbdda111570">介绍如何使用JNI</a>的文章</td></tr><tr><td><del>Extension Mechanism</del></td><td></td><td><del>支持扩展，jar包置于/jdk/jre/lib/ext,<br>二进制文件置于/jdk/jre/bin，<br>JVM会作为可信任文件加载，不做安全检查。<br>已弃用，未来版本删除此功能</del></td></tr><tr><td><del>Override Mechanism</del></td><td></td><td><del>除JCP外定义的Java API，可以覆盖成新版本<br>作为认可标准版本。未来版本删除功能</del></td></tr><tr><td>IDL</td><td>org.omg.CORBA<br>org.omg.CosNaming<br>org.omg.PortableServer<br>org.omg.PortableInterceptor<br>org.omg.DynamicAny</td><td>使分布式、支持Web的Java应用可以基于IIOP<br>协议透明地调用远程服务</td></tr><tr><td>JDBC</td><td>java.sql<br>javax.sql</td><td>通用数据访问接口，需要驱动进行连接。如常用的<br>mysql-connector-java.jar</td></tr><tr><td>JNDI</td><td>javax.naming</td><td>提供命名和目录功能，以通用方式访问各种服务。<br>如Spring定义的jndi-lookup可以用于<br>Wildfly部署的应用程序来建立数据库连接</td></tr><tr><td>RMI</td><td>java.rmi</td><td>提供调用远程JVM中的Java对象的方法，<br>使用对象序列化来封装和解析</td></tr><tr><td>RMI-IIOP</td><td>org.omg.CORBA<br>org.omg.CosNaming<br>org.omg.PortableServer<br>javax.rmi</td><td>通过Internet Inter-ORB协议技术进行<br>Java远程方法调用RMI编程模型可通过<br>RMI API进行CORBA服务器和应用程序的编程。</td></tr><tr><td>Scripting</td><td>javax.script</td><td>脚本引擎接口，可以实现动态脚本与java的<br>交互，Java SE套件中含有nashorn引擎，<br>可见nashorn.jar</td></tr></tbody></table><h2 id="JDK提供的工具"><a href="#JDK提供的工具" class="headerlink" title="JDK提供的工具"></a>JDK提供的工具</h2><p>所有提供的工具按照类别分组情况如下，具体的使用方法可以下载JDK的文档查看。</p><ul><li><strong>基本工具</strong> (appletviewer, extcheck, jar, java, javac, javadoc, javah, javap, jdb, jdeps,jaotc)</li><li><strong>安全工具</strong> (keytool, jarsigner, policytool, kinit, klist, ktab)</li><li><strong>国际化工具</strong> (native2ascii)</li><li><strong>RMI工具</strong> (rmic, rmiregistry, rmid, serialver)</li><li><strong>Java IDL和RMI-IIOP工具</strong> (tnameserv, idlj, orbd, servertool)</li><li><strong>部署工具</strong> (javapackager, pack200, unpack200)</li><li><strong>Java Web Start工具</strong> (javaws)</li><li><strong>故障排除，性能分析，监视和管理工具</strong> (jcmd, jconsole, jmc, jvisualvm)</li><li><strong>Web服务工具</strong> (schemagen, wsgen, wsimport, xjc)</li></ul><h2 id="Java-9及以后"><a href="#Java-9及以后" class="headerlink" title="Java 9及以后"></a>Java 9及以后</h2><p>上述的组成架构图，是基于Java 8的解析。在Java9前，由于之前JRE必须要整体部署运行，会造成一定程度不期望的性能影响或者资源消耗。Oracle公司针对这方面的考虑，在JCP组织上做了很多的工作，终于在Java 9上实现了模块化。</p><p>Java 9之前是通过不同的package和jar对功能做区分隔离，Java9后，可以通过不同的module进行隔离。</p><p>如果打开JDK 9后文件夹，你会发现jre文件夹不存在了，出现了新的文件夹：jmods。文件夹下面的每个文件都是一个组件，每个组件都会有一个module-info.class文件。打开文件你会发现，存在着类似nodejs等语言常用的关键字：用requires引入需要的组件、 用exports暴露的包名；其中java.base是最基础的模块，其他组件不需要显示requires。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> java.sql &#123; </span><br><span class="line">    <span class="keyword">requires</span> transitive java.logging;</span><br><span class="line">    <span class="keyword">requires</span> transitive java.transaction.xa;</span><br><span class="line">    <span class="keyword">requires</span> transitive java.xml;</span><br><span class="line">    <span class="keyword">exports</span> java.sql; </span><br><span class="line">    <span class="keyword">exports</span> javax.sql; </span><br><span class="line">    uses java.sql.Driver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>笔者也还未曾使用过Java 8以后的版本编写过项目，童鞋们有没有优秀的文章分享分享呢？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上述的篇幅，我们可以知道：</p><ol><li>JVM在JRE(JDK)中是以动态链接库的形式存在的，windows中是jvm.dll，linux中是libjvm.so</li><li>JDK 8有3种实现的compact JRE，数字越大，功能越丰富</li><li>组成架构图中的Java SE API部分，位于/jre/lib和/jre/lib/ext文件夹下jar包中</li><li>rt.jar包是Java SE最为核心的包</li><li>组成架构图中的Tools部分，位于jdk的bin目录下的可执行的二进制文件</li><li>JDK 9后 Java SE API不再是以jar形式存在，而是.jmod文件，针对不同的功能进行模块化</li></ol><p>现在对JDK的组成结构到实际开发运用是否有了进一步理解呢？有疑问的地方，欢迎童鞋们留言讨论！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果你是刚要被Java军训的新兵，可有几时对环境搭建而不知所措？又如若你是驰骋Java战场多年的老将，可曾拿起陪伴你许久的82年的JDK回味一番？今天我们就来道一道JDK，重新来认识认识这个既熟悉又陌生的伙伴。&lt;/p&gt;
&lt;p&gt;既然要唠唠JDK，首先想到的，肯定是要了解下都是</summary>
      
    
    
    
    
    <category term="基础知识" scheme="http://joruachan.cn/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="JDK" scheme="http://joruachan.cn/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>disruptor初次见面</title>
    <link href="http://joruachan.cn/2021-09-15/the-first-time-2-meet-disruptor/"/>
    <id>http://joruachan.cn/2021-09-15/the-first-time-2-meet-disruptor/</id>
    <published>2021-09-14T16:00:00.000Z</published>
    <updated>2022-08-17T16:05:57.206Z</updated>
    
    <content type="html"><![CDATA[<p>每每复习Java数据结构时候，总感觉在队列中找不到一个适合高并发场景的队列。JDK提供的队列模型不尽人意，那么今天将要像大家简单介绍下：</p><p>Disruptor，一个适用于多线程间高并发交换数据的有界队列；</p><p>简单说几点，就能体现Disruptor的神奇：</p><ol><li>在并发情况下，普通的内存队列处理速度，和IO速度处于同一个数量级；</li><li>基于Disruptor开发的系统<strong>单线程</strong>能支撑<strong>每秒600万</strong>订单；</li><li>生产者消费者的环形队列，<strong>无锁</strong>；</li></ol><p>怎么样，是不是魅力很大？确实，目前GitHub上已经有14k+的Star了。</p><p>大家可以先阅读下其<a href="https://github.com/LMAX-Exchange/disruptor">GitHub站</a>，以及文档。我会将Disruptor的详细说明列入博客计划。</p><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/LMAX-Exchange/disruptor"><img src="https://github-readme-stats.vercel.app/api/pin/?username=LMAX-Exchange&repo=disruptor&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=LMAX-Exchange&repo=disruptor&show_owner=true" srcset="data:image/png;base64,666"/></a>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;每每复习Java数据结构时候，总感觉在队列中找不到一个适合高并发场景的队列。JDK提供的队列模型不尽人意，那么今天将要像大家简单介绍下：&lt;/p&gt;
&lt;p&gt;Disruptor，一个适用于多线程间高并发交换数据的有界队列；&lt;/p&gt;
&lt;p&gt;简单说几点，就能体现Disruptor的神</summary>
      
    
    
    
    <category term="随笔" scheme="http://joruachan.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="高并发" scheme="http://joruachan.cn/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    <category term="框架" scheme="http://joruachan.cn/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="数据结构" scheme="http://joruachan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>这是我的一半2021</title>
    <link href="http://joruachan.cn/2021-09-07/half-of-2021/"/>
    <id>http://joruachan.cn/2021-09-07/half-of-2021/</id>
    <published>2021-09-07T15:34:22.000Z</published>
    <updated>2022-08-17T16:05:57.203Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章起笔时间，2021年9月7日晚上。 </p><p>间隔上篇博文，又过去了5个多月。中间发生了很多事，似乎明白了很多，让我坚定了很多选择；但是似乎又增添了不少疑惑，疑惑那些打破我认知的事情。不要觉得我矫情，也许你们觉得很正常，于我来说，可能正在经历生活、职场等等方面的历练。</p><p>简单说下吧。</p><ul><li>婚姻，我们在三年恋爱后，终于————我迎娶她成为了丈夫，她嫁给我成为了妻子；感谢有她，庆幸有她！</li><li>新房，房子在婚姻上我认为是个必需品，媳妇和我花了不少时间、心思在装配上，完美收官让我们心满意足；愿家愈来愈好！</li><li>离职，陪上家公司经历了一段最困难的时期，不舍归不舍，生活还是要继续；祝福它吧！</li><li>新城市，朝钱看所以我换了城市，上午仍在家，下午奔至另一个城市，快节奏让我觉得哪哪都是陌生的；但愿新城市温柔点！</li><li>新工作，在我第四年的工作经验情况下，让我时时自己问自己：原来你不知道的还是有这么多？当然更多的原因是没有接触过的业务；卷起来吧！</li></ul><p>2021不一般！带着憧憬，带着责任，全力以赴。<br>当然现在，所有的一切都逐渐稳定了。所以，我，Jorua又回来啦！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章起笔时间，2021年9月7日晚上。 &lt;/p&gt;
&lt;p&gt;间隔上篇博文，又过去了5个多月。中间发生了很多事，似乎明白了很多，让我坚定了很多选择；但是似乎又增添了不少疑惑，疑惑那些打破我认知的事情。不要觉得我矫情，也许你们觉得很正常，于我来说，可能正在经历生活、职场等等方面</summary>
      
    
    
    
    <category term="随便聊聊" scheme="http://joruachan.cn/categories/%E9%9A%8F%E4%BE%BF%E8%81%8A%E8%81%8A/"/>
    
    
    <category term="除了工作以外的" scheme="http://joruachan.cn/tags/%E9%99%A4%E4%BA%86%E5%B7%A5%E4%BD%9C%E4%BB%A5%E5%A4%96%E7%9A%84/"/>
    
  </entry>
  
  <entry>
    <title>史上最全synchronized关键字总结</title>
    <link href="http://joruachan.cn/2021-03-22/synchronized-summary/"/>
    <id>http://joruachan.cn/2021-03-22/synchronized-summary/</id>
    <published>2021-03-21T16:00:00.000Z</published>
    <updated>2022-08-17T16:06:04.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章思路"><a href="#文章思路" class="headerlink" title="文章思路"></a>文章思路</h2><p>我在阅读文章时，更希望文章有个提纲或者思路，在阅读前可以理解他的思路，这样能快速明白他想说什么，将要怎么说。</p><p>本篇文章编写的思路：</p><ol><li>回顾下理论知识：信号量。因为信号量是解决并发过程中互斥和同步问题的最基础的模型;</li><li>介绍管程模型，管程模型是针对信号量的一个改进模型;</li><li>再介绍Java中是如何实现和使用管程模型的;</li><li>最后介绍下Java对synchronized重量级锁的优化;</li></ol><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>你的脑袋里，是不是还能蹦出共享资源、临界区、P方法、V方法等等字眼词汇？那说明你的课本知识还是很扎实的！</p><p>信号量机制是由荷兰学者Dijkstra提出的进程同步工具，它被大量使用在处理机系统和计算机网络中！其中，包含了两个重要属性和两个重要的方法。</p><p>PS：我这里介绍的内容，为了更好的理解经过了一定的加工，不完全和理论介绍一致！</p><h3 id="两个重要属性"><a href="#两个重要属性" class="headerlink" title="两个重要属性"></a>两个重要属性</h3><ol><li>count，共享资源数量，count &gt; 0表示还存在共享资源可以获取，count &lt; 0则表示共享资源已经获取完了，只能等资源被释放；</li><li>等待队列，当count &lt; 0时，线程需阻塞直到资源释放，这些线程需要加入到等待队列中；</li></ol><h3 id="两个重要方法"><a href="#两个重要方法" class="headerlink" title="两个重要方法"></a>两个重要方法</h3><ol><li>P：获取资源，即对count-1，如果结果&gt;=0，则获取资源成功；但是结果&lt;0的话，线程则加入到等待队列并进入阻塞状态；</li><li>V：释放资源，即对count+1，如果结果&gt;0，则不做特殊操作；但是结果&lt;=0，则表示有线程需要共享资源，则从等待队列中唤醒一个线程恢复执行；</li></ol><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>只有P和V方法能操作count属性；</li><li>P和V方法必须成对出现，否则对共享资源的控制不准确；</li><li>P方法可能阻塞，但是不能无限期阻塞；</li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>易造成死锁</p><p>  如果一段逻辑中存在多个信号量间的交互，有着很经典的问题：比如A和B间，A依赖着B，B又依赖着A，如果控制不合理，很容易造成死锁；</p></li><li><p>饥饿现象</p><p>  调度器的不公平，会造成线程等待时间较长产生饥饿现象；</p></li><li><p>对程序员不友好</p><p>  如果依靠信号量间来完成多个临界区的同步或者互斥，那么会有大量的P/V方法，难以维护；</p></li></ul><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>管程模型是在信号量的基础上改进的模型，很大程度上解决了上述信号量存在的问题，并且隐藏了很多同步细节。</p><h3 id="改进点"><a href="#改进点" class="headerlink" title="改进点"></a>改进点</h3><p><strong>· 吞吐量提高</strong></p><p>管程模型允许多个进（线）程先进入模型，再根据同步条件来判断是否能进入临界区；而信号量模型同一个信号量不论何种情况，都只能一个进（线）程进入；</p><p><strong>· 条件队列（条件同步）</strong></p><p>管程模型在信号量模型的基础上，添加了条件同步概念。通过使用条件队列，已经获得共享资源的进（线）程可以释放共享资源，并将进（线）程添加到条件队列中阻塞，一直等到某个条件成立，使得该进（线）程回到等待队列重新获取共享资源，再继续执行后续逻辑；具体的代码实现可以参考j.u.c中的Condition接口和具体实现；</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/synchronized-summary/compare-mointor-semaphere.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/synchronized-summary/compare-mointor-semaphere.png" srcset="data:image/png;base64,666" alt="管程和信号量的比较，图片来自于网络"/></div><span class="image-caption">管程和信号量的比较，图片来自于网络</span></div><h3 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h3><p>在信号量的模型中，一个共享变量需要一个信号量模型支持；如果存在多个共享变量，就需要多个信号量来支持。</p><p>举例说明：两个共享资源A和B以及对应的信号量Sa和Sb；一个线程Ta利用Sa信号量的P方法获取到共享资源A，然后尝试获取共享资源B（未执行V方法）；另一个线程Tb在Ta获取到A的同时也获取到B，然后Tb又需要获取A。则最后的现象就是Ta需要等待Tb释放B，Tb在等Ta释放A，谁也不放过谁，而造成了死锁；具体可以参照伪代码理解：</p><figure class="highlight plaintext"><figcaption><span>信号量死锁伪代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Sa&#123;</span><br><span class="line">    int A;</span><br><span class="line">    P()&#123;</span><br><span class="line">        // 阻塞直到满足条件</span><br><span class="line">        if(--A &gt;= 0) &#123;</span><br><span class="line">            ... </span><br><span class="line">            Sb.P()</span><br><span class="line">            ... </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sb&#123;</span><br><span class="line">    int B;</span><br><span class="line">    P()&#123;</span><br><span class="line">        // 阻塞直到满足条件</span><br><span class="line">        if(--B &gt;= 0) &#123;</span><br><span class="line">            ...</span><br><span class="line">            Sa.P()</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管程则针对上述问题，提出一个更方便、更易理解的模型。<wavy>从线程的角度去管理和协调共享资源，拥有管程的线程可以放弃使用权，并等待恢复。</wavy> 从而解决上述列出的伪代码的问题了！</p><figure class="highlight plaintext"><figcaption><span>管程伪代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">Sa&#123;</span><br><span class="line">    int A;</span><br><span class="line">    P()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(获取共享资源A成功)&#123;</span><br><span class="line">                ... </span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    if (获取共享资源B成功) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                        // 唤起等待资源B的线程</span><br><span class="line">                        Sb.notify()</span><br><span class="line"></span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 释放共享资源A的控制权</span><br><span class="line">                        Sa.wait()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                Sa.notify()    </span><br><span class="line">                break; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait()&#123; // 释放A的控制权 &#125;</span><br><span class="line"></span><br><span class="line">    notify()&#123; // 唤起等待A的线程 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sb&#123;</span><br><span class="line">    int B;</span><br><span class="line">    P()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(获取共享资源B成功)&#123;</span><br><span class="line">                ... </span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    if (获取共享资源A成功) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                        // 唤起等待资源A的线程</span><br><span class="line">                        Sa.notify()</span><br><span class="line"></span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 释放共享资源B的控制权</span><br><span class="line">                        Sb.wait()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                Sb.notify()    </span><br><span class="line">                break; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait()&#123; // 释放B的控制权 &#125;</span><br><span class="line"></span><br><span class="line">    notify()&#123; // 唤起等待B的线程 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，通过wait和notify两个方法，可以很好地解决多个共享变量间的协调问题；</p><h3 id="MESA模型"><a href="#MESA模型" class="headerlink" title="MESA模型"></a>MESA模型</h3><p>管程的具体实现，当前最流行的就是MESA模型。它有个基本的编程范式：在一个while循环里面调用wait()，增加一个超时参数防止饥饿；</p><p>除了MESA模型，还有Hoare模型和Brinch Hanson 模型，感兴趣的同学可以了解下。</p><h2 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h2><h3 id="字节码表现"><a href="#字节码表现" class="headerlink" title="字节码表现"></a>字节码表现</h3><p>我们先来举个例子：</p><figure class="highlight java"><figcaption><span>SynchronizedTest.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">normalMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步方法，只能锁住当前实例的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步代码块，这里可以指定同步资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncCodeBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，一个普通的方法，一个同步方法，还有一个同步代码块。我们先通过javac编译成.class文件，再用javap查看其汇编指令，具体观察下如何运作的。</p><figure class="highlight plaintext"><figcaption><span>汇编指令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;SynchronizedTest.java&quot;</span><br><span class="line">public class SynchronizedTest &#123;</span><br><span class="line">int count;</span><br><span class="line"></span><br><span class="line">public SynchronizedTest();</span><br><span class="line">Code:</span><br><span class="line">0: aload_0</span><br><span class="line">1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">4: aload_0</span><br><span class="line">5: iconst_0</span><br><span class="line">6: putfield      #2                  // Field count:I</span><br><span class="line">9: return</span><br><span class="line"></span><br><span class="line">public void normalMethod();</span><br><span class="line">Code:</span><br><span class="line">0: aload_0</span><br><span class="line">1: dup</span><br><span class="line">2: getfield      #2                  // Field count:I</span><br><span class="line">5: iconst_1</span><br><span class="line">6: iadd</span><br><span class="line">7: putfield      #2                  // Field count:I</span><br><span class="line">10: return</span><br><span class="line"></span><br><span class="line">public synchronized void syncMethod();</span><br><span class="line">Code:</span><br><span class="line">0: aload_0</span><br><span class="line">1: dup</span><br><span class="line">2: getfield      #2                  // Field count:I</span><br><span class="line">5: iconst_1</span><br><span class="line">6: iadd</span><br><span class="line">7: putfield      #2                  // Field count:I</span><br><span class="line">10: return</span><br><span class="line"></span><br><span class="line">public void syncCodeBlock();</span><br><span class="line">Code:</span><br><span class="line">0: aload_0</span><br><span class="line">1: dup</span><br><span class="line">2: astore_1</span><br><span class="line">3: monitorenter</span><br><span class="line">4: aload_0</span><br><span class="line">5: dup</span><br><span class="line">6: getfield      #2                  // Field count:I</span><br><span class="line">9: iconst_1</span><br><span class="line">10: iadd</span><br><span class="line">11: putfield      #2                  // Field count:I</span><br><span class="line">14: aload_1</span><br><span class="line">15: monitorexit</span><br><span class="line">16: goto          24</span><br><span class="line">19: astore_2</span><br><span class="line">20: aload_1</span><br><span class="line">21: monitorexit</span><br><span class="line">22: aload_2</span><br><span class="line">23: athrow</span><br><span class="line">24: return</span><br><span class="line">Exception table:</span><br><span class="line">from    to  target type</span><br><span class="line">4    16    19   any</span><br><span class="line">19    22    19   any</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要关注第24～32行和第34～54行；可以很快的发现，同步方法其实和普通方法在字节码角度去看是没有任何区别的；<br>但是，同步方法块中，是通过显式的monitorenter和monitorexit，JVM在执行时候便会进行同步处理，具体如何操作我们稍作讲解；</p><p>同步方法到底是怎么操作的呢？其实，了解过Class文件的同学应该知道Class文件中有方法表，方法表定义了每个方法信息method_info，该结构体中有个access_flags字段记录方法的访问标记，其中synchronized就会被记录。<br>当方法被调用的时候发现access_flags定义了synchronized标记，如果是静态方法则针对该Class对象进行同步处理，如果是实例方法则针对实例对象进行同步处理；</p><h3 id="ObjectMonitor——管程在JVM中的实现"><a href="#ObjectMonitor——管程在JVM中的实现" class="headerlink" title="ObjectMonitor——管程在JVM中的实现"></a>ObjectMonitor——管程在JVM中的实现</h3><p>上一小节中说到了，JVM如何知道程序员定义的方法或者代码块需要同步处理；那么说到JVM同步处理，就必须要知道ObjectMonitor结构体了。</p><p>管程在JVM中的具体实现是ObjectMonitor，可以参考HotSpot源码：ObjectMonitor.hpp；主要的属性包含：</p><ol><li>_entryList：希望进入管程monitor对象，处于blocked状态的线程；</li><li>_waitSet：已经获得过锁，但是在条件队列上处于wait状态的线程；</li></ol><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/synchronized-summary/object-monitor.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/synchronized-summary/object-monitor.png" srcset="data:image/png;base64,666" alt="ObjectMonitor图解，图片源于百度搜索结果"/></div><span class="image-caption">ObjectMonitor图解，图片源于百度搜索结果</span></div><p>当线程处理到同步逻辑时候，会进入同步对象的ObjectMonitor中。线程会<strong>enter</strong>放置到EntrySet集合中。当线程<strong>acquire</strong>到资源后，就进入临界区中；如果需要条件等待，则<strong>release</strong>锁并放置到WaitSet集合中等待再次被唤醒，重新<strong>acquire</strong>进入临界区；如果逻辑处理完成，便会<strong>release</strong>锁，并退出临界区。</p><h3 id="Mutex-Lock"><a href="#Mutex-Lock" class="headerlink" title="Mutex Lock"></a>Mutex Lock</h3><p>ObjectMonitor只是高级语言写出的结构体，在转换成010101二进制码给CPU处理时，硬件是如何保证线程间的互斥性呢？</p><p>我们先引出操作系统中的Mutex Lock。这个锁是具有排他性的，所有线程中只会有一个线程才能获取到；没有获取到锁的线程可能会进入睡眠，这样就会存在线程上下文切换的小号。ObjectMonitor就是基于此实现的。操作系统的MutexLock是怎么实现的，笔者也不是特别清楚，就不随意发言了。有兴趣的同学可以研究下，顺便留言和大家分享下呢！或者如果有高手的话，还请多多指教！</p><p>从硬件的角度看互斥性的实现，就是需要保证多个CPU核之间的执行唯一性。MESI协议、总线锁，都是实现互斥的关键技术。</p><h2 id="synchronized锁优化"><a href="#synchronized锁优化" class="headerlink" title="synchronized锁优化"></a>synchronized锁优化</h2><p>上面介绍了管程的概念以及实现，相信大家都有了一定的认知了。但是！我这边提出一个场景：</p><ul><li>只有少量的线程抢占共享资源</li></ul><p>因为上面说到是由MutexLock实现的，不论多少个线程，哪怕只有一个线程在抢占时，也是需要锁住CPU核，从而造成资源浪费；所以MutexLock称之为重量级锁。Java 1.6后引入了偏向锁和轻量级锁，线程在较少的抢占情况下，无需通过MutexLock来获取锁；</p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>一个Java对象在JVM中，分成三个区域：对象头、实例数据、对齐填充；</p><ul><li>实例数据：4个字节对齐，存储类的数据，包括父类属性，如果是数组还包括数据长度；</li><li>对象头：一部分存储自身运行时数据，如GC年代、哈希码、锁信息等，在32/64位机器占用32/64位，官方称为<strong>Mark Word</strong>；另一部分则存储对象类型数据的指针，数组对象还需存储数组的长度；</li><li>填充数据：JVM要求对象起始地址必须是8字节的倍数，仅为了对齐；</li></ul><p>JVM为了空间效率，Mark Word设计成非固定数据结构，以便存储更多数据；具体如下:</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/synchronized-summary/markword.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/synchronized-summary/markword.png" srcset="data:image/png;base64,666" alt="MarkWord不同形式，图片源于网络"/></div><span class="image-caption">MarkWord不同形式，图片源于网络</span></div><h3 id="锁的升级和撤销"><a href="#锁的升级和撤销" class="headerlink" title="锁的升级和撤销"></a>锁的升级和撤销</h3><p>上面其实已经说过，synchronized在未优化前，不论何种场景都是按照重量级锁进行互斥的；Java1.6后，JVM会根据不同的场景做了优化以及升级；</p><p>上小节的图片中可以看到MarkWord会存在四种状态：无锁、偏向锁、轻量级锁以及重量级锁，按照这个顺序不断升级锁来适应不同的场景。<strong>注：synchronized不能降级！</strong></p><h4 id="无锁升级成偏向锁"><a href="#无锁升级成偏向锁" class="headerlink" title="无锁升级成偏向锁"></a>无锁升级成偏向锁</h4><p>如果当前只有一个线程运行，此时只会加上偏向锁。具体过程是:</p><ol><li>线程会先查看MarkWord的锁标记位和偏向锁标记位，如果是无锁状态，则当前线程可获得偏向锁；</li><li>通过CAS无锁的方式将MarkWord的偏向锁标记位修改为1，以及赋值当前线程ID；</li></ol><h4 id="偏向锁撤销，升级成轻量级锁"><a href="#偏向锁撤销，升级成轻量级锁" class="headerlink" title="偏向锁撤销，升级成轻量级锁"></a>偏向锁撤销，升级成轻量级锁</h4><p>如上，已经有一个线程A获得了偏向锁，此时又有一个线程B来获取锁：</p><ol><li>线程B会先查看MarkWord的锁标记位和偏向锁标记位，发现是偏向锁状态；</li><li>判断偏向锁线程id是否为自己，如果是则已经获取；如果不是自己，则尝试通过CAS设置MarkWord，则需要发起撤销偏向锁；</li><li>暂停线程A，解偏向锁并将线程id置为空，再恢复线程B；<strong>（此阶段会STW, 撤销完后MarkWord此时无锁状态）</strong></li><li>线程A和B会竞争轻量级锁，都会先在自己的线程栈上分配空间并复制对象头的MarkWord作为Displaced MarkWord，A、B通过CAS无锁方式将对象头的Markword指向自己栈空间；</li><li>只有一个线程能成功，该线程获得轻量级锁；</li></ol><h4 id="轻量级锁撤销，升级成重量级锁"><a href="#轻量级锁撤销，升级成重量级锁" class="headerlink" title="轻量级锁撤销，升级成重量级锁"></a>轻量级锁撤销，升级成重量级锁</h4><p>假设线程A获得轻量级锁，线程B未获取到；</p><ol><li>线程B会继续CAS尝试将Markword指向自己的DisplacedMarkWord；当尝试到一定次数后仍失败，则<strong>将锁膨胀修改成重量级锁，阻塞住</strong>；</li><li>线程A会将对象头的MarkWord通过CAS修改恢复，释放锁，并唤醒线程B；</li><li>此时对象头的锁标记位就是10了，即重量级锁。A和B就需要进行介绍的重量级锁的竞争了；</li></ol>]]></content>
    
    
    <summary type="html">这里应该可谓史上对synchronized关键字最全的总结了，笔者可谓呕心沥血的文章！不得不看！</summary>
    
    
    
    
    <category term="Java面试复习" scheme="http://joruachan.cn/tags/Java%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="多线程" scheme="http://joruachan.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="基础知识" scheme="http://joruachan.cn/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>MySQL统计信息研究</title>
    <link href="http://joruachan.cn/2021-01-31/mysql-stats-info-explore/"/>
    <id>http://joruachan.cn/2021-01-31/mysql-stats-info-explore/</id>
    <published>2021-01-30T16:00:00.000Z</published>
    <updated>2021-02-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阅读此文，最好事先了解MySQL对SQL语句的执行流程。<br>笔者后续会针对性地补充相关内容，敬请期待！</p></blockquote><h2 id="统计信息简介"><a href="#统计信息简介" class="headerlink" title="统计信息简介"></a>统计信息简介</h2><p>了解过SQL语句执行流程的童鞋应该都知道，查询优化器会根据统计信息和代价模型计算每个执行计划的成本大小，从而选择成本最小的执行计划；总而言之，统计信息是决定最终explain所见的执行计划的一个重要因素！</p><p>统计信息分成非持久化统计信息和持久化统计信息；统计信息可由MySQL专门的后台线程dict_stats_thread自动触发更新，也可手动更新；</p><h3 id="非持久化统计信息"><a href="#非持久化统计信息" class="headerlink" title="非持久化统计信息"></a>非持久化统计信息</h3><p>非持久化的统计信息是存在内存中的，数据库重启后会丢失；所以在重启时，大量表会更新统计信息，会对数据库实例造成较大影响；</p><p>开启方式：全局变量，针对全局表的默认设置，INNODB_STATS_PERSISTENT = OFF; 或者只针对某个表，在create或者alter时候设置STATS_PERSISTENT = 0;</p><p>自动更新 (主要) 场景：<br>    1. 距离上次统计信息更新，表中1/16的数据被修改；<br>    2. innodb_stats_on_metadata=ON的情况下，SHOW TABLE STATUS，SHOW INDEX以及查询INFORMATION_SCHEMA下的TABLES或STATISTICS；</p><p>上面说到，非持久化统计信息在数据库重启的时候会大量更新，对数据库造成影响，所以生产上几乎不会采用这种方案；</p><h3 id="持久化统计信息"><a href="#持久化统计信息" class="headerlink" title="持久化统计信息"></a>持久化统计信息</h3><p>持久化的统计信息是存在物理表中的，数据库重启后不会丢失；具体的表为：mysql库下的innodb_index_stats和innodb_table_stats；</p><p>开启方式：5.6.6版本后MySQL默认开启持久化统计信，即INNODB_STATS_PERSISTENT = ON；</p><p>自动更新（主要）场景：<br>    1. 距离上次统计信息更新，表中1/10的数据被修改；<br>    2. 新建索引，重建索引，truncate；</p><h2 id="innodb-table-stats表"><a href="#innodb-table-stats表" class="headerlink" title="innodb_table_stats表"></a>innodb_table_stats表</h2><p>先看下innodb_table_stats表的DDL</p><figure class="highlight sql"><figcaption><span>innodb_table_stats DDL</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `innodb_table_stats` (</span><br><span class="line">  `database_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `table_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `last_update` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `n_rows` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `clustered_index_size` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `sum_of_other_index_sizes` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`database_name`,`table_name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin STATS_PERSISTENT<span class="operator">=</span><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="字段介绍"><a href="#字段介绍" class="headerlink" title="字段介绍"></a>字段介绍</h3><ul><li>database_name: 数据库名称；</li><li>table_name: 表名称；</li><li>last_update: 更新时间；</li><li>n_rows: 表数据的总行数；</li><li>clustered_index_size: 聚簇索引的总页数；</li><li>sum_of_other_index_sizes: 非聚簇索引的总页数；</li></ul><figure class="highlight md"><figcaption><span>引申介绍</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">聚簇索引：innodb引擎，必须有且只有一个主键，这种索引是将数据和索引存储在一起的，只要找到索引的位置就可以找到行数据；</span><br><span class="line">但是通过辅助索引需要经历两次查询，先通过辅助索引找到主键位置，再通过聚簇索引找到数据； </span><br><span class="line"> </span><br><span class="line">非聚簇索引：myisam引擎，索引和数据是分开存储的，索引的叶子节点指向数据行地址；辅助索引和主键索引以及数据文件都是独立的；</span><br><span class="line">myisam通过key<span class="emphasis">_buffer把索引先缓存到内存中，当通过索引访问数据时，在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因；</span></span><br><span class="line"><span class="emphasis"></span></span><br></pre></td></tr></table></figure><h2 id="innodb-index-stats表"><a href="#innodb-index-stats表" class="headerlink" title="innodb_index_stats表"></a>innodb_index_stats表</h2><p>先看下innodb_index_stats表的DDL</p><figure class="highlight sql"><figcaption><span>innodb_index_stats DDL</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `innodb_index_stats` (</span><br><span class="line">  `database_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `table_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `index_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `last_update` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `stat_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `stat_value` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `sample_size` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `stat_description` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`database_name`,`table_name`,`index_name`,`stat_name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin STATS_PERSISTENT<span class="operator">=</span><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="字段介绍-1"><a href="#字段介绍-1" class="headerlink" title="字段介绍"></a>字段介绍</h3><ul><li>database_name: 数据库名称；</li><li>table_name: 表名称；</li><li>index_name: 索引名称；</li><li>last_update: 更新时间；</li><li>stat_name: 统计信息名；</li><li>stat_value: 统计信息值；</li><li>sample_size: 采样大小；</li><li>stat_description: 类型说明；</li></ul><h3 id="统计项说明"><a href="#统计项说明" class="headerlink" title="统计项说明"></a>统计项说明</h3><p>如果翻看innodb_index_stats表数据，你会发现每个索引都会有多个统计项(stat_name)；主要如下：</p><table><thead><tr><th>stat_name统计项</th><th>stat_value含义</th></tr></thead><tbody><tr><td>size</td><td>索引的页数量</td></tr><tr><td>n_leaf_pages</td><td>叶子节点的数量</td></tr><tr><td>n_diff_pfxNN</td><td>索引上唯一值的数量；因为索引可能是多列，所以NN表示从左递增的列组合唯一值的数量；注意如果是普通索引除去自身索引列的统计，还会加上唯一索引列进行统计；</td></tr></tbody></table><p>了解stat_name和stat_value的具体含义，可以在解决或者优化慢查询问题上，起到一定的作用。如果统计值远小于实际值，查询优化器基本上不会选择该索引进行查询检索；</p><figure class="highlight md"><figcaption><span>n_diff_pfxNN举例说明</span></figcaption><table><tr><td class="code"><pre><span class="line">假设表有字段：a、b、c、d、e，唯一索引：uix<span class="emphasis">_a_</span>b<span class="emphasis">_c(a, b, c)， 普通索引：idx_</span>d<span class="emphasis">_e(d, e)；</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">针对唯一索引uix_</span>a<span class="emphasis">_b_</span>c则会有统计项： </span><br><span class="line"><span class="bullet">1.</span> n<span class="emphasis">_diff_</span>pfx01表示列a上的唯一值数量；</span><br><span class="line"><span class="bullet">2.</span> n<span class="emphasis">_diff_</span>pfx02表示a,b两列组合的唯一值数量；</span><br><span class="line"><span class="bullet">3.</span> n<span class="emphasis">_diff_</span>pfx03表示a,b,c三列组合的唯一值数量；</span><br><span class="line"></span><br><span class="line">针对普通索引：idx<span class="emphasis">_d_</span>e则会有统计项： </span><br><span class="line"><span class="bullet">1.</span> n<span class="emphasis">_diff_</span>pfx01表示d列上的唯一值数量；</span><br><span class="line"><span class="bullet">2.</span> n<span class="emphasis">_diff_</span>pfx02表示d, e两列组合的唯一值数量；</span><br><span class="line"><span class="bullet">3.</span> n<span class="emphasis">_diff_</span>pfx03表示d, e, a三列组合的唯一值数量；</span><br><span class="line"><span class="bullet">3.</span> n<span class="emphasis">_diff_</span>pfx04表示d, e, a, b四列组合的唯一值数量；</span><br><span class="line"><span class="bullet">3.</span> n<span class="emphasis">_diff_</span>pfx05表示d, e, a, b, c五列组合的唯一值数量；</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="手动更新统计信息"><a href="#手动更新统计信息" class="headerlink" title="手动更新统计信息"></a>手动更新统计信息</h2><p>执行ANALYZE TABLE table_name。注意：执行此语句时，需要保证用户拥有select和insert的权限；执行时，会持有innodb表的readonly锁，从而会短暂导致表的写入、更新、删除操作；</p><h2 id="统计信息不准确，怎么办？"><a href="#统计信息不准确，怎么办？" class="headerlink" title="统计信息不准确，怎么办？"></a>统计信息不准确，怎么办？</h2><p>如我的随笔中，<a href="../../2021-01-30/mysql-stats-info/">《什么？MySQL还有统计信息一说？》</a>一文中，有说到生产环境更新了索引，经过执行计划的查看，查询优化器并没有使用新建的索引；</p><p>运维查看了统计信息后，发现统计信息不准确，便执行ANALYZE TABLE table_name刷新了统计信息，便可以正常使用索引查询了。</p><p>所以，我们来整理下，如果发现索引没有正常被使用，发现和解决问题的大致思路。如有不适当的地方，欢迎大家留言点拨和斧正！</p><p><img src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/mysql-stats-info-explore/mysql_query_slow_ideas.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/mysql-stats-info-explore/mysql_query_slow_ideas.png" srcset="data:image/png;base64,666" alt="慢查询解决思路"></p><ul><li>第一步：检查索引是否建立起来，如果这步都漏了，是得好好反思下了；</li><li>第二步：索引正常建立，查询还是很慢，则查看执行计划，判断索引是否正常被使用；如果没被使用则走第三步，被使用了则走第四步；</li><li>第三步：索引正常建立，但是执行计划没有选择该索引；则查看统计信息，如果统计信息异常，则执行ANALYZE TABLE table_name刷新统计信息；还没有恢复，则调大采样变量大小；</li><li>第四步：索引正常建立，执行计划也选择了该索引，在SQL无问题的前提下需要考虑设计方面；</li></ul><p>注： 以上步骤建立在SQL没有问题的情况之上！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;&lt;p&gt;阅读此文，最好事先了解MySQL对SQL语句的执行流程。&lt;br&gt;笔者后续会针对性地补充相关内容，敬请期待！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;统计信息简介&quot;&gt;&lt;a href=&quot;#统计信息简介&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://joruachan.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>什么？MySQL还有统计信息一说？</title>
    <link href="http://joruachan.cn/2021-01-30/mysql-stats-info/"/>
    <id>http://joruachan.cn/2021-01-30/mysql-stats-info/</id>
    <published>2021-01-29T16:00:00.000Z</published>
    <updated>2022-08-17T16:05:57.204Z</updated>
    
    <content type="html"><![CDATA[<p>笔者最近在项目上对现有表进行了结构优化，并对一个常用表添加了索引。可谓测试环境玩漂移，生产环境怕翻车啊。上线验证的那一刻，突然发现一个类似报表功能的查询SQL极慢！</p><h1 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h1><ol><li><p>故障简查</p><p> 检查添加索引索引的SQL，查看SQL执行结果，检查DDL。一顿操作后，表象上没看出问题</p></li><li><p>比较执行计划</p><p> 连接sit环境执行explain，发现没问题，索引正常用上的。在生产的dbms上执行explain，发现索引没有用上，join查询时全表扫描了</p></li><li><p>查看MySQL版本</p><p> sit和prd环境都是5.7.22版本，看样子也不是版本不同造成的</p></li><li><p>再次分析</p><p> 既然MySQL版本也一样，DDL也一样，为啥执行计划就是不一样呢？一边猜测着是不是有什么缓存，一边为了节约发布时间，让运维帮忙先把索引删掉再重新添加下</p></li><li><p>问题暴露</p><p> 也许是运维对问题的普遍性或者敏感性，过了两三分钟，没对索引操作便通知我们好了！心里便纳了闷了，运维大牛确实牛啊！咨询了一番，便引出今天的话题了：刷新了<emp>统计信息</emp></p></li></ol><h1 id="统计信息研究"><a href="#统计信息研究" class="headerlink" title="统计信息研究"></a>统计信息研究</h1><p>笔者学识浅薄，未曾了解“统计信息”。特此奉上，统计信息研究！大神勿喷！</p><p>本文为随笔，具体的研究文章见：</p><div class="tag link"><a class="link-card" title="MySQL统计信息研究" href="https://joruachan.cn/2021-01-31/mysql-stats-info-explore/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/mysql-stats-info-explore/cover.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/mysql-stats-info-explore/cover.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">MySQL统计信息研究</p><p class="url">https://joruachan.cn/2021-01-31/mysql-stats-info-explore/</p></div></a></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;笔者最近在项目上对现有表进行了结构优化，并对一个常用表添加了索引。可谓测试环境玩漂移，生产环境怕翻车啊。上线验证的那一刻，突然发现一个类似报表功能的查询SQL极慢！&lt;/p&gt;
&lt;h1 id=&quot;背景说明&quot;&gt;&lt;a href=&quot;#背景说明&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="随笔" scheme="http://joruachan.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="MySQL" scheme="http://joruachan.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>纪实:nodejs+hexo+volantis快速构建个人Blog</title>
    <link href="http://joruachan.cn/2021-01-17/fast-build-blog/"/>
    <id>http://joruachan.cn/2021-01-17/fast-build-blog/</id>
    <published>2021-01-16T16:00:00.000Z</published>
    <updated>2022-08-17T16:05:57.203Z</updated>
    
    <content type="html"><![CDATA[<p>即使身为一个钢铁直男的技术人，能拥有一个分享自己技术心得和生活分享的小窝，想必是每个技术人都考虑过的事情吧!</p><p>笔者这就告诉你一个秘密：只需执行几行命令，改点配置，一个端庄不失典雅的博客网站就能生成好！</p><h2 id="搭建环境简介"><a href="#搭建环境简介" class="headerlink" title="搭建环境简介"></a>搭建环境简介</h2><p>nodejs + hexo;</p><p>nodejs的安装本文不再介绍，不熟悉的同学可前往<a href="https://nodejs.org/">nodejs官网</a>学习并安装；本站选用hexo的volantis主题介绍建站的， hexo提供了330款主题，如有需要，<a href="https://hexo.io/themes/">可前往查看其他主题</a></p><div class="tag link"><a class="link-card" title="NodeJs" href="https://nodejs.org/en/"><div class="left"><img src="https://nodejs.org/static/images/logo.svg" class="lazyload" data-srcset="https://nodejs.org/static/images/logo.svg" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">NodeJs</p><p class="url">https://nodejs.org/en/</p></div></a></div><div class="tag link"><a class="link-card" title="Hexo" href="https://hexo.io/"><div class="left"><img src="https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg" class="lazyload" data-srcset="https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">Hexo</p><p class="url">https://hexo.io/</p></div></a></div><div class="tag link"><a class="link-card" title="Volantis" href="https://volantis.js.org/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png" srcset="data:image/png;base64,666"/></div><div class="right"><p class="text">Volantis</p><p class="url">https://volantis.js.org/</p></div></a></div><h2 id="hexo简介"><a href="#hexo简介" class="headerlink" title="hexo简介"></a>hexo简介</h2><p><a href="https://hexo.io/">hexo</a> 自称为：快速、简洁且高效的博客框架。</p><p>笔者用起来确实还可以，大概介绍下几个特性：</p><ul><li>提供了不同的layout，可将文章存为草稿，需要时publish即可；</li><li>可维护全局的数据，在source/_data文件夹下添加yaml文件，通过site.data获取；</li><li>可指定文件的特有变量，通过<a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a>实现；</li><li>支持模板，在scaffolds文件夹下可自定义模板，并进行发布；</li><li>支持标签插件，可以在文章文件中使用标签%%来插入特定内容；</li><li>提供<a href="https://hexo.io/zh-cn/docs/commands">命令行操作</a>，如：hexo init初始化项目、hexo new新建文章、hexo pulish发布草稿文件、hexo generate生成静态文件、hexo server启动服务器；</li></ul><h2 id="hexo搭建博客步骤"><a href="#hexo搭建博客步骤" class="headerlink" title="hexo搭建博客步骤"></a>hexo搭建博客步骤</h2><ol><li>前提是必须安装好git和nodejs；</li><li>执行 “npm install -g hexo-cli”，安装好hexo；</li><li>选定文件夹，通过 “hexo init $folder” 初始化一个名为 $folder 的文件夹；</li><li>cd $folder, 再执行npm install，至此hexo的博客框架已经搭建完成！</li></ol><p>完成上述步骤后，可执行hexo server, 访问<a href="http://localhost:4000/">http://localhost:4000</a>, 会发现一个HelloWorld页面已经可以访问！</p><p><img src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/fast-build-blog/hexo_build_page.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/fast-build-blog/hexo_build_page.png" srcset="data:image/png;base64,666" alt="初步搭建页面"></p><h2 id="选用volantis主题"><a href="#选用volantis主题" class="headerlink" title="选用volantis主题"></a>选用volantis主题</h2><ol><li>设置项目使用的主题: 项目根目录下的_config.yml文件中设置 theme: volantis;</li><li>如果Hexo版本在5.0.2及以上，可以直接通过npm i hexo-theme-volantis进行安装；笔者为了项目的可读性，采用了源代码拷贝到theme文件夹的方案（记得删除.git文件夹,否则git提交时会出问题!）</li><li>按照依赖的插件：npm i hexo-generator-search hexo-generator-json-content(站内搜索)，npm i hexo-renderer-stylus（Stylus 渲染器）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/fast-build-blog/volantis_config.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/fast-build-blog/volantis_config.png" srcset="data:image/png;base64,666" alt="volantis配置"></p><p>完成上述步骤后执行hexo server, 访问<a href="http://localhost:4000/">http://localhost:4000</a>, 是不是发现端庄不失典雅的博客网站已经完成了！</p><p><img src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/fast-build-blog/volantis_preview.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/fast-build-blog/volantis_preview.png" srcset="data:image/png;base64,666" alt="volantis预览"></p><h2 id="尝试新建文章"><a href="#尝试新建文章" class="headerlink" title="尝试新建文章"></a>尝试新建文章</h2><p>执行 hexo new post $newPostName，会在_post文件夹下新建一个名为$newPostName的md文件，一个新的文章便建立完成。</p><p>这时你只需要关注你的博文输出即可啦！</p><p><img src="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/fast-build-blog/new_post.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/JoruaChan/BlogImages/fast-build-blog/new_post.png" srcset="data:image/png;base64,666" alt="newPost"></p><h2 id="发布至GitHub-Pages"><a href="#发布至GitHub-Pages" class="headerlink" title="发布至GitHub Pages"></a>发布至GitHub Pages</h2><p>如果你期望能通过GitHub Pages来访问你的博客网站，做如下几步：</p><ol><li>通过GitHub新建一个repository，名为：&lt;你的 GitHub 用户名&gt;.github.io；</li><li>本地检出该repository；</li><li>在博客源码的项目中执行命令：hexo generate –deploy，会生成public文件夹，该文件夹里便是博客所有的静态页面文件；</li><li>将public文件夹中的文件全部拷贝到新建repository的master分支下；</li><li>将master文件推送至远程master分支即可！</li><li>静待一会，访问：http://&lt;你的 GitHub 用户名&gt;.github.io便能访问你自定义的博客了！</li></ol><div class="note paperclip"><p>如果你有自己的域名，可以在域名解析配置成 记录类型：CNAME，记录值：&lt;你的 GitHub 用户名&gt;.github.io。 注意了！！！ 此时还需要在GitHub Page项目中根目录下加上名为CNAME的文件，文件内容为你自己的域名。</p></div><p>正如你看到的，搭建一个个人博客网站就是如此便捷！</p><p>如果你喜欢的话，点个赞，分享分享下吧！谢谢~</p>]]></content>
    
    
    <summary type="html">只需执行几行命令，改点配置，快速构建端庄不失典雅的个人Blog网站!</summary>
    
    
    
    
  </entry>
  
</feed>
